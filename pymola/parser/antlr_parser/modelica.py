#!/usr/bin/env python
"""
Modelica compiler.
"""
from __future__ import print_function
import sys
import antlr4
import antlr4.Parser
from generated.ModelicaLexer import ModelicaLexer
from generated.ModelicaParser import ModelicaParser
from generated.ModelicaListener import ModelicaListener
import argparse
import jinja2

#pylint: disable=invalid-name, no-self-use, missing-docstring, unused-variable, protected-access
#pylint: disable=too-many-public-methods

class SympyPrinter(ModelicaListener):

    #-------------------------------------------------------------------------
    # Setup
    #-------------------------------------------------------------------------

    def __init__(self, parser, trace):
        """
        Constructor
        """
        self._val_dict = {}
        self.result = None
        self._data = {
            'parameters': {},
            'variables': [],
            'equations': [],
            'init': {},
        }
        self._parser = parser
        self._trace = trace
        self.indent = "    "

    @staticmethod
    def print_indented(ldr, s):
        if s is not None:
            for line in s.split('\n'):
                print(ldr, line)

    def setValue(self, ctx, val):
        """
        Sets tree values.
        """
        if ctx.depth() == 1:
            self.result = val
        else:
            self._val_dict[ctx] = val

    def getValue(self, ctx):
        """
        Gets tree values.
        """
        assert ctx is not None
        if ctx.depth() == 1:
            return self.result
        else:
            try:
                return self._val_dict[ctx]
            except KeyError:
                return None

    def enterEveryRule(self, ctx):
        if self._trace:
            ldr = " "*(ctx.depth()-1)
            rule = self._parser.ruleNames[ctx.getRuleIndex()]

            print(ldr, rule + "{")
            in_str = ctx.getText()
            if in_str > 0:
                print(ldr, "==============================")
                print(ldr, "INPUT\n")
                self.print_indented(ldr, ctx.getText())
                print(ldr, "==============================\n")

    def visitTerminal(self, node):
        pass

    def visitErrorNode(self, node):
        pass

    def exitEveryRule(self, ctx):
        rule = self._parser.ruleNames[ctx.getRuleIndex()]
        if self._trace:
            ldr = " "*ctx.depth()
            lines = None
            try:
                lines = self.getValue(ctx)
            except KeyError as e:
                pass

            if lines is not None:
                print(ldr, "==============================")
                print(ldr, "OUTPUT\n")
                self.print_indented(ldr, lines)
                print(ldr, "==============================\n")

            print(ldr + '} //' + rule + '\n')
        if self.getValue(ctx) is None:
            raise RuntimeError("no value set for {:s}:\ninput:\n{:s}".format(rule, ctx.getText()))

    #-------------------------------------------------------------------------
    # Top Level
    #-------------------------------------------------------------------------

    def exitStored_definition(self, ctx):
        composition = self.getValue(ctx.class_definition()[0]\
                .class_specifier().composition())
        self.result = """
#############################################################################
# Automatically generated by pymola

from __future__ import print_function
import sympy
import sympy.physics.mechanics as mech
sympy.init_printing()
mech.init_vprinting()
import scipy.integrate
import pylab as pl

t = sympy.symbols('t')

{composition:s}

x = sympy.Matrix(x)
x_dot = x.diff(t)

sol = sympy.solve(eqs, x_dot)

f = sympy.Matrix([sol[xi] for xi in x_dot])
print(x)
print(f)

p_vect = [locals()[key] for key in p]

print(p_vect)

f_lam = sympy.lambdify((t,x,p_vect), f)

x0 = [0,0]
p0 = [1,1]

sim = scipy.integrate.ode(f_lam)
sim.set_initial_value([0,0])
sim.set_f_params(p0)
tf = 10
dt = 0.1

data = {{
    'x': [],
    't': [],
}}

while  sim.t < tf:
    sim.integrate(sim.t + dt)
    data['x'] += [sim.y]
    data['t'] += [sim.t]

pl.plot(data['t'], data['x'])
pl.show()

#############################################################################
""".format(**locals())

    def exitComposition(self, ctx):
        declaration = self.getValue(ctx.element_list()[0])
        equations = self.getValue(ctx.equation_section()[0])
        self.setValue(ctx, """
# declaration
{declaration:s}

{equations:s}
""".format(**locals()))

    def exitElement_list(self, ctx):
        s = "p = {}\nx0 = {}\nx = []\n"
        for element in ctx.element():
            s += self.getValue(element)
        self.setValue(ctx, s)

    def exitElement(self, ctx):
        self.setValue(ctx, self.getValue(ctx.component_clause()))

    def exitEquation_section(self, ctx):
        str_eq = "eqs=["
        str_when = ""
        for eq in ctx.equation():
            data = self.getValue(eq)
            if len(data) <= 0:
                continue
            print("eq type:", type(eq.equation_options()))
            if isinstance(eq.equation_options(), ModelicaParser.Equation_simpleContext):
                str_eq += "\n{self.indent:s}{data:s},".format(**locals())
                print("SIMPLE")
            elif isinstance(eq.equation_options(), ModelicaParser.Equation_whenContext):
                str_when += "\n{self.indent:s}{data:s}".format(**locals())
            else:
                raise IOError('equation type not supported yet')
        str_eq += "\n{self.indent:s}]\n".format(**locals())
        str_when += ""
        self.setValue(ctx, """
# equations
{str_eq:s}

# when equations
{str_when:s}
""".format(**locals()))

    def exitComponent_clause(self, ctx):
        s = ""
        if ctx.type_prefix().getText() == 'parameter':
            # store all parameters
            for comp in ctx.component_list().component_declaration():
                name = comp.declaration().IDENT().getText()
                val = comp.declaration().modification().expression().getText()
                self._data['parameters'][name] = float(val)
                s += "{:s} = sympy.symbols('{:s}')\n".format(name, name)
                s += "p['{:s}'] = {:s}\n".format(name, val)
        else:
            # store all variables
            for comp in ctx.component_list().component_declaration():
                name = comp.declaration().IDENT().getText()
                mod = comp.declaration().modification().class_modification()
                val = mod.argument_list().getText()
                self._data['init'][name] = val
                s += "{:s} = mech.dynamicsymbols('{:s}')\n".format(name, name)
                s += "x0['{:s}'] = {:s}\n".format(name, val)
                s += "x += [{:s}]\n".format(name)
                # s += "{:s} = {:s}\n".format(name, val)
        self.setValue(ctx, s)

    def exitClass_prefixes(self, ctx):
        # don't care about prefixes for now
        self.setValue(ctx, '')

    def exitName(self, ctx):
        self.setValue(ctx, ctx.getText())

    def exitType_specifier(self, ctx):
        self.setValue(ctx, self.getValue(ctx.name()))

    def exitModification_class(self, ctx):
        mod = self.getValue(ctx.class_modification())
        if ctx.expression() is not None:
            expr = self.getValue(ctx.expression())
            self.setValue(ctx, "{:s} = {:s}".format(mod, expr))
        else:
            self.setValue(ctx, "{:s}".format(mod))

    def exitModification_assignment(self, ctx):
        expr = self.getValue(ctx.expression())
        self.setValue(ctx, "= {:s}".format(expr))

    def exitModification_assignment2(self, ctx):
        # TODO how to handle := operator?, is it just assignment
        expr = self.getValue(ctx.expression())
        self.setValue(ctx, "= {:s}".format(expr))

    def exitDeclaration(self, ctx):
        # set above based on component type
        self.setValue(ctx, "")

    def exitComment(self, ctx):
        self.setValue(ctx, "# {:s}".format(ctx.getText()))

    def exitString_comment(self, ctx):
        self.setValue(ctx, "# {:s}".format(ctx.getText()))

    def exitComponent_declaration(self, ctx):
        # set above based on component type
        self.setValue(ctx, "")

    def exitComponent_list(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitElement_modification(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitElement_modification_or_replaceable(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitType_prefix(self, ctx):
        self.setValue(ctx, "")

    def exitArgument(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitArgument_list(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitClass_modification(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitComponent_reference(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitFunction_arguments(self, ctx):
        if ctx.function_argument() is not None:
            s = ""
            args = ctx.function_argument()
            n = len(args)
            for i in range(n):
                s += "{:s}".format(self.getValue(args[i]))
                if i < n-1:
                    s += ", "
            self.setValue(ctx, s)
        elif ctx.named_arguments() is not None:
            args = self.getValue(ctx.named_arguments())
            self.setValue(ctx, args)

    def exitArguement_function(self, ctx):
        name = self.getValue(ctx.name())
        if ctx.named_arguments() is not None:
            named_arguments = self.getValue(ctx.named_arguements())
        else:
            named_arguments = ""
        self.setValue(ctx, "{name:s}({named_arguments:s})")

    def exitArgument_expression(self, ctx):
        expr = self.getValue(ctx.expression())
        self.setValue(ctx, expr)

    def exitFunction_call_args(self, ctx):
        args = ctx.function_arguments()
        if  args is not None:
            self.setValue(ctx, self.getValue(args))
        else:
            self.setValue(ctx, "")

    def exitClass_specifier(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitClass_definition(self, ctx):
        # TODO
        self.setValue(ctx, "")

    def exitClass_stored_definition(self, ctx):
        # TODO
        self.setValue(ctx, "")

    #-------------------------------------------------------------------------
    # Equation
    #-------------------------------------------------------------------------

    def exitEquation(self, ctx):
        self.setValue(ctx, self.getValue(ctx.equation_options()))

    def exitEquation_simple(self, ctx):
        self.setValue(
            ctx,
            "{:s} - {:s}".format(
                self.getValue(ctx.simple_expression()),
                self.getValue(ctx.expression())))

    def exitEquation_if(self, ctx):
        raise NotImplementedError("")

    def exitEquation_for(self, ctx):
        raise NotImplementedError("")

    def exitEquation_connect_clause(self, ctx):
        raise NotImplementedError("")

    def exitEquation_function(self, ctx):
        self.setValue(ctx, "{name:s}({args:})".format(**{
            'name': self.getValue(ctx.name()),
            'args': self.getValue(ctx.function_call_args())
            }))

    def exitWhen_equation(self, ctx):
        exprs = ctx.expression()
        eqns = ctx.equation()
        t = jinja2.Template("""
if {{ walker.getValue(exprs[0]) -}}:
    {{ walker.getValue(eqns[0]) }}
{% for i in range(1, exprs|length) %}
elif {{ walker.getValue(exprs[i]) }}:
    {{ walker.getValue(eqns[i]) }}
{% endfor %}
""")
        # self.setValue(ctx, t.render({
            # 'walker': self,
            # 'exprs': exprs,
            # 'eqns': eqns,
            # }))
        self.setValue(ctx, '')

    def exitEquation_when(self, ctx):
        self.setValue(ctx, self.getValue(ctx.when_equation()))

    #-------------------------------------------------------------------------
    # Expression
    #-------------------------------------------------------------------------

    def exitExpression_simple(self, ctx):
        self.setValue(ctx, self.getValue(ctx.simple_expression()))

    def exitSimple_expression(self, ctx):
        # TODO, can have more than one expr
        self.setValue(ctx, self.getValue(ctx.expr()[0]))

    def exitExpr_primary(self, ctx):
        self.setValue(ctx, self.getValue(ctx.primary()))

    def exitExpr_neg(self, ctx):
        self.setValue(ctx, '-({:s})'.format(self.getValue(ctx.expr())))

    def exitExpr_rel(self, ctx):
        self.setValue(ctx, '({:s} {:s} {:s})'.format(
            self.getValue(ctx.expr()[0]),
            ctx.op.text,
            self.getValue(ctx.expr()[1])))

    def exitExpr_mul(self, ctx):
        self.setValue(ctx, '({:s} {:s} {:s})'.format(
            self.getValue(ctx.expr()[0]),
            ctx.op.text,
            self.getValue(ctx.expr()[1])))

    #-------------------------------------------------------------------------
    # Primary
    #-------------------------------------------------------------------------

    def exitPrimary_unsigned_number(self, ctx):
        self.setValue(ctx, ctx.getText())

    def exitPrimary_component_reference(self, ctx):
        self.setValue(ctx, ctx.getText())

    def exitPrimary_derivative(self, ctx):
        name = ctx.function_call_args().function_arguments().function_argument()[0].getText()
        self._data['variables'] += [name]
        self.setValue(ctx, '{:s}.diff(t)'.format(name))

    def exitPrimary_string(self, ctx):
        self.setValue(ctx, ctx.getText())

    def exitPrimary_false(self, ctx):
        self.setValue(ctx, ctx.getText())

def main(argv):
    #pylint: disable=unused-argument
    "The main function"
    parser = argparse.ArgumentParser()
    parser.add_argument('filename')
    parser.add_argument('-t', '--trace', action='store_true')
    parser.set_defaults(trace=False)
    args = parser.parse_args()
    text = antlr4.FileStream(args.filename)
    lexer = ModelicaLexer(text)
    stream = antlr4.CommonTokenStream(lexer)
    parser = ModelicaParser(stream)
    tree = parser.stored_definition()
    # print(tree.toStringTree(recog=parser))
    sympyPrinter = SympyPrinter(parser, args.trace)
    walker = antlr4.ParseTreeWalker()
    walker.walk(sympyPrinter, tree)

    with open(args.filename+'.py', 'w') as f:
        f.write(sympyPrinter.result)

    # trace = TraceListener(parser)
    # walker.walk(trace, tree)

if __name__ == '__main__':
    main(sys.argv)

# vim: set et ft=python fenc=utf-8 ff=unix sts=0 sw=4 ts=4 :
