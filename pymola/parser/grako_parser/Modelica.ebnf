(* B.2.1 Stored Definition -Within *)

stored_definition =
    [ 'within'  >> within:[name] ';' ]
    { final:['final'] class_definition:class_definition ';'}+;
    (* forcing one class with + so we get useful debugging*)

(* B.2.2 Class Definition *)

class_definition =
    encapsulated:['encapsulated']
    class_prefixes:class_prefixes
    class_specifier:class_specifier;

class_prefixes =
    partial:['partial']
    type:( 'class' | 'model' | ['operator'] 'record' | 'block' 
    | ['expandable'] 'connector' | 'type' | 'package' | 
    [('pure'|'impure')] ['operator'] 
    'function' | 'operator' );

class_specifier =
    (class_specifier_long:class_specifier_long |
    class_specifier_short:class_specifier_short |
    class_specifier_enum:class_specifier_enum |
    class_specifier_der:class_specifier_der |
    class_specifier_extends:class_specifier_extends) ;

class_specifier_long =
    name:IDENT
    comment:string_comment
    composition:composition 
    'end' >> name_check:IDENT;

class_specifier_short =
    name:IDENT '='
    base_prefix:base_prefix
    base_name:name
    subscripts:[array_subscripts]
    modification:[class_modification]
    comment:comment;

class_specifier_enum =
    name:IDENT
    '=' 'enumeration' 
    '(' enumeration: ( [enum_list] | ':' ) ')'
    comment:comment;

class_specifier_der =
    name:IDENT '=' 'der'  '(' name ','
    IDENT { ',' IDENT } ')' comment:comment;

class_specifier_extends =
    'extends'  name:IDENT
    class_modification:[class_modification]
    comment:string_comment composition:composition
    'end' >> name_check:IDENT;

base_prefix =
    type_prefix;

enum_list = enumeration_literal { ',' enumeration_literal};

enumeration_literal = name:IDENT comment:comment;

composition =
    element_list:element_list
    { access:'public'  element_list:element_list |
      access:'protected'  element_list:element_list |
      equation_section:equation_section |
      algorithm_section:algorithm_section
    }
    [ 'external'  [language_specification:language_specification]
               [function_call:external_function_call]
               [function_call_anotation:annotation] ';' ]
    [ annotation:annotation ';' ] ;

language_specification =
    @:STRING;

external_function_call =
    [ component_reference '=' ]
    IDENT '(' [expression_list] ')' ;

element_list =
    { @:element >> ';' } ;

element =
    import_clause:import_clause |
    extends_clause:extends_clause |
    redeclare:['redeclare']
    final:['final']
    inner:['inner']
    outer:['outer']
    ( ( class_definition:class_definition | component_clause:component_clause) |
    replaceable:'replaceable'
    ( class_definition:class_definition | component_clause:component_clause)
    [constraining_clause:constraining_clause comment:comment]) ;

import_clause =
    'import' ( alias:IDENT '=' name:name | name:name ['.' ( '*' | 
    '{' import_list '}' ) ] ) comment ;

import_list =
    IDENT [ ',' import_list ] ;

(* B.2.3 Extends *)

extends_clause =
    'extends'  name [class_modification] [annotation];

constraining_clause =
    'constrainedby'  name [class_modification];

(* B.2.4 Component Clause *)

component_clause = type_prefix:type_prefix
	type_specifier:type_specifier
	array_subscripts:[array_subscripts]
    component_list:component_list;

type_prefix =
    flow_type: ['flow'|'stream']
    value_type: ['discrete'|'parameter'|'constant']
    io_type: ['input'|'output'];

type_specifier =
    @:name;

component_list =
    @component_declaration { ',' @component_declaration } ;

component_declaration =
    @:declaration condition:[condition_attribute] comment:comment ;

condition_attribute =
    'if' @expression ;

declaration =
    name:IDENT array_subscripts:[array_subscripts]
    modification:[modification] ;

(* B.2.5 Modification *)

modification =
    (class_modification:class_modification
        [ '=' >> expression:expression ])
    | '=' >> expression:expression
    | ':=' >> expression:expression;

class_modification =
    '(' >> argument_list:[argument_list] ')';

argument_list =
    @:argument { ',' @:argument } ;

argument =
    @:element_modification_or_replaceable
    | @:element_redeclaration ;

element_modification_or_replaceable =
    each:['each'] final:['final']
    ( element_modification:element_modification |
      element_replaceable:element_replaceable);

element_modification =
    name:name modification:[modification] comment:string_comment;

element_redeclaration =
    'redeclare'  each:['each'] final:['final']
    ( ( short_class_definition:short_class_definition |
        component_clause1:component_clause1) | 
        element_replaceable:element_replaceable );

element_replaceable =
    'replaceable'  ( short_class_definition:short_class_definition |
    component_clause1:component_clause1)
    constraining_clause:[constraining_clause];

component_clause1 =
    type_prefix:type_prefix
    type_specifier:type_specifier
    component_declaration1:component_declaration1;

component_declaration1 =
    declaration:declaration comment:comment;

short_class_definition =
    class_prefixes:class_prefixes IDENT '='
    ( base_prefix:base_prefix base_name:name
    array_subscripts:[array_subscripts]
    class_modification:[class_modification]
    comment:comment |
    'enumeration' '(' ( [enum_list:enum_list] | ':' ) ')'
    comment:comment );

(* B.2.6 Equations *)

equation_section =
    initial:['initial'] 'equation' >> { equation:equation >> ';' };

algorithm_section =
    initial:['initial'] 'algorithm' >> { statement:statement >> ';' };

equation =
    ( simple_expression '=' >> expression
    | if_equation
    | for_equation
    | connect_clause
    | when_equation
    | name function_call_args )
    comment ;

statement =
    ( component_reference  ( ':=' >> expression | function_call_args )
    | '('  output_expression_list ')' ':=' >> component_reference function_call_args
    | 'break'
    | 'return'
    | if_statement
    | for_statement
    | while_statement
    | when_statement )
    comment ;

if_equation =
    'if' expression 'then'
    { equation  ';' }
    { 'elseif' expression 'then'
    { equation ';' }
    }
    [ 'else'
    { equation ';' }
    ]
    'end' 'if' ;

if_statement =
    'if' expression 'then'
    { statement  ';' }
    { 'elseif' expression 'then'
    { statement ';' }
    }
    [ 'else'
    { statement ';' }
    ]
    'end' 'if';

for_equation =
    'for' for_indices 'loop'
    { equation  ';' }
    'end' 'for';

for_statement =
    'for' for_indices 'loop'
    { statement  ';' }
    'end' 'for';

for_indices =
    for_index {','  for_index};

for_index =
    IDENT [ 'in' expression ];

while_statement =
    'while' expression 'loop'
    { statement ';' }
    'end' 'while';

when_equation =
    'when' expression 'then'
    { equation ';' }
    { 'elsewhen' expression 'then'
    { equation ';' } }
    'end' 'when';

when_statement =
    'when' expression 'then'
    { statement ';' }
    { 'elsewhen' expression 'then'
    { statement ';' } }
    'end' 'when';

connect_clause =
    'connect' '(' component_reference ',' component_reference ')';

(* B.2.7 Expression *)

expression =
    simple_expression
    | ('if' expression 'then' expression
    { 'elseif' expression 'then' expression }
    'else' expression);

simple_expression =
    simple_expression:(logical_expression
    [ ':' logical_expression [ ':' logical_expression ] ]);

logical_expression =
    logical_expression:(logical_term { 'or' logical_term });

logical_term =
    logical_term:(logical_factor { 'and' logical_factor });

logical_factor =
    not:['not'] relation:relation;

relation =
    arithmetic_expression:(arithmetic_expression [ rel_op arithmetic_expression ]);

rel_op =
    @:('<' | '<=' | '>' | '>=' | '==' | '<>');

arithmetic_expression =
    [add_op] term { add_op term };

add_op =
    @:('+' | '-' | '.+' | '.-');

term =
    factor { mul_op factor };

mul_op =
    @:('*' | '/' | '.*' | './');

factor =
    primary [ ('^' | '.^') primary ];

primary =
    UNSIGNED_NUMBER
    | STRING
    | 'false'
    | 'true'
    | ( name | 'der' | 'initial' ) function_call_args
    | component_reference
    | '(' output_expression_list ')'
    | '[' expression_list { ';' expression_list } ']'
    | '{' function_arguments '}'
    | 'end';

name =
    [ '.' ] @:IDENT { '.' @:IDENT };

component_reference =
    [ '.' ] IDENT [ array_subscripts ] { '.' IDENT [ array_subscripts ] };

function_call_args =
    '(' [function_arguments] ')';

function_arguments =
    function_argument [ ',' function_arguments | 'for' for_indices ]
    | named_arguments;

named_arguments = named_argument [ ',' named_arguments ];

named_argument = IDENT '=' function_argument;

function_argument =
    'function' name '(' [named_arguments] ')' | expression;

output_expression_list =
    [expression] { ',' [expression] };

expression_list =
    expression { ',' expression };

array_subscripts =
    '[' subscript { ',' subscript } ']';

subscript =
    ':' | expression;

comment =
    comment:string_comment annotation:[annotation];

string_comment =
    @:[ STRING { '+' STRING } ];

annotation =
    'annotation' @:class_modification;

re_IDENT = ?/[_a-zA-Z][_a-zA-Z0-9]*/?;
re_STRING = ?/"[^"]+"/?;
re_UNSIGNED_NUMBER = ?/[0-9]+([\.][0-9]+)?([eE][\+\-]?[0-9]+)?/?;

(* creating rules so whitespace skipped *)
IDENT = re_IDENT; 
STRING = re_STRING;
UNSIGNED_NUMBER = re_UNSIGNED_NUMBER;


(*
vi:ts=4:sw=4:expandtab:
*)
