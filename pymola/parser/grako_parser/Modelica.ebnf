(* B.2.1 Stored Definition -Within *)

stored_definition =
    [ 'within'  [within:name] ';' ]
    { final:['final'] class_definition:class_definition ';'}+;
    (* forcing one class with + so we get useful debugging*)

(* B.2.2 Class Definition *)

class_definition =
    encapsulated:['encapsulated']
    prefixes:class_prefixes
    specifier:class_specifier ;

class_prefixes =
    partial:['partial']
    type:( 'class' | 'model' | ['operator'] 'record' | 'block' 
    | ['expandable'] 'connector' | 'type' | 'package' | 
    [('pure'|'impure')] ['operator'] 
    'function' | 'operator' ) ;

class_specifier =
    @(class_specifier_long |
    class_specifier_short |
    class_specifier_enum |
    class_specifier_der |
    class_specifier_extends) ;

class_specifier_long =
    name:IDENT comment:string_comment
    composition:composition  'end' name_check:IDENT;

class_specifier_short =
    name:IDENT '='
    base_prefix:base_prefix
    base_name:name
    subscripts:[array_subscripts]
    modification:[class_modification]
    comment:comment ;

class_specifier_enum =
    name:IDENT '=' 'enumeration' 
    '(' ( enum:[enum_list] | ':' ) ')'
    commnet:comment;

class_specifier_der =
    name:IDENT '=' 'der'  '(' name ','
    IDENT { ',' IDENT } ')' comment;

class_specifier_extends =
    'extends'  name:IDENT [class_modification]
    string_comment composition
     'end' IDENT;

base_prefix =
    type_prefix;

enum_list = enumeration_literal { ',' enumeration_literal};

enumeration_literal = IDENT comment;

composition =
    element_list:element_list
    { access:'public'  element_list:element_list |
      access:'protected'  element_list:element_list |
      equation_section:equation_section |
      algorithm_section:algorithm_section
    }
    [ 'external'  [language_specification]
               [external_function_call] [annotation] ';' ]
    [ annotation ';' ] ;

language_specification =
    STRING;

external_function_call =
    [ component_reference '=' ]
    IDENT '(' [expression_list] ')' ;

element_list =
    { element:element  ';' } ;

element =
    import_clause:import_clause |
    extends_clause:extends_clause |
    redeclare:['redeclare']
    final:['final']
    inner:['inner']
    outer:['outer']
    ( ( class_definition | component_clause) |
    'replaceable' ( class_definition | component_clause)
    [constraining_clause comment]) ;

import_clause =
    'import' ( alias:IDENT '=' name:name | name:name ['.' ( '*' | 
    '{' import_list '}' ) ] ) comment ;

import_list =
    IDENT [ ',' import_list ] ;

(* B.2.3 Extends *)

extends_clause =
    'extends'  name [class_modification] [annotation];

constraining_clause =
    'constrainedby'  name [class_modification];

(* B.2.4 Component Clause *)

component_clause = type:type_prefix
	type_specifier:type_specifier
	array_subscripts:[array_subscripts]
	name:IDENT ;

type_prefix =
    flow_type: ['flow'|'stream']
    value_type: ['discrete'|'parameter'|'constant']
    io_type: ['input'|'output'];

type_specifier =
    @:name;

component_list =
    component_declaration { ',' component_declaration } ;

component_declaration =
    name:declaration condition:[condition_attribute] comment:comment ;

condition_attribute =
    'if' expression ;

declaration =
    IDENT [array_subscripts] [modification] ;

(* B.2.5 Modification *)

modification =
    class_modification [ '=' expression ]
    | '=' expression
    | ':=' expression;

class_modification =
    '(' [argument_list] ')';

argument_list =
    argument { ',' argument } ;

argument =
    element_modification_or_replaceable
    | element_redeclaration ;

element_modification_or_replaceable =
    ['each'] ['final']  ( element_modification | element_replaceable);

element_modification =
    name [modification] string_comment;

element_redeclaration =
    'redeclare'  ['each'] ['final']
    ( ( short_class_definition | component_clause1) | 
        element_replaceable );

element_replaceable =
    'replaceable'  ( short_class_definition | component_clause1)
    [constraining_clause];

component_clause1 =
    type_prefix type_specifier component_declaration1;

component_declaration1 =
    declaration comment;

short_class_definition =
    class_prefixes IDENT '='
    ( base_prefix name [array_subscripts]
    [class_modification] comment |
    'enumeration' '(' ( [enum_list] | ':' ) ')' comment );

(* B.2.6 Equations *)

equation_section =
    initial:['initial'] 'equation'  { equation:equation ';' };

algorithm_section =
    initial:['initial'] 'algorithm'  { statement:statement ';' };

equation =
    ( simple_expression '='  expression
    | if_equation
    | for_equation
    | connect_clause
    | when_equation
    | name function_call_args )
    comment ;

statement =
    ( component_reference  ( ':=' expression | function_call_args )
    | '('  output_expression_list ')' ':=' component_reference function_call_args
    | 'break'
    | 'return'
    | if_statement
    | for_statement
    | while_statement
    | when_statement )
    comment ;

if_equation =
    'if' expression 'then'
    { equation  ';' }
    { 'elseif' expression 'then'
    { equation ';' }
    }
    [ 'else'
    { equation ';' }
    ]
    'end' 'if' ;

if_statement =
    'if' expression 'then'
    { statement  ';' }
    { 'elseif' expression 'then'
    { statement ';' }
    }
    [ 'else'
    { statement ';' }
    ]
    'end' 'if';

for_equation =
    'for' for_indices 'loop'
    { equation  ';' }
    'end' 'for';

for_statement =
    'for' for_indices 'loop'
    { statement  ';' }
    'end' 'for';

for_indices =
    for_index {','  for_index};

for_index =
    IDENT [ 'in' expression ];

while_statement =
    'while' expression 'loop'
    { statement ';' }
    'end' 'while';

when_equation =
    'when' expression 'then'
    { equation ';' }
    { 'elsewhen' expression 'then'
    { equation ';' } }
    'end' 'when';

when_statement =
    'when' expression 'then'
    { statement ';' }
    { 'elsewhen' expression 'then'
    { statement ';' } }
    'end' 'when';

connect_clause =
    'connect' '(' component_reference ',' component_reference ')';

(* B.2.7 Expression *)

expression =
    simple_expression
    | ('if' expression 'then' expression
    { 'elseif' expression 'then' expression }
    'else' expression);

simple_expression =
    logical_expression [ ':' logical_expression [ ':' logical_expression ] ];

logical_expression =
    logical_term { 'or' logical_term };

logical_term =
    logical_factor { 'and' logical_factor };

logical_factor =
    ['not'] relation;

relation =
    arithmetic_expression [ rel_op arithmetic_expression ];

rel_op =
    '<' | '<=' | '>' | '>=' | '==' | '<>';

arithmetic_expression =
    [add_op] term { add_op term };

add_op =
    '+' | '-' | '.+' | '.-';

term =
    factor { mul_op factor };

mul_op =
    '*' | '/' | '.*' | './';

factor =
    primary [ ('^' | '.^') primary ];

primary =
    UNSIGNED_NUMBER
    | STRING
    | 'false'
    | 'true'
    | ( name | 'der' | 'initial' ) function_call_args
    | component_reference
    | '(' output_expression_list ')'
    | '[' expression_list { ';' expression_list } ']'
    | '{' function_arguments '}'
    | 'end';

name =
    [ '.' ] @:IDENT { '.' @:IDENT };

component_reference =
    [ '.' ] IDENT [ array_subscripts ] { '.' IDENT [ array_subscripts ] };

function_call_args =
    '(' [function_arguments] ')';

function_arguments =
    function_argument [ ',' function_arguments | 'for' for_indices ]
    | named_arguments;

named_arguments = named_argument [ ',' named_arguments ];

named_argument = IDENT '=' function_argument;

function_argument =
    'function' name '(' [named_arguments] ')' | expression;

output_expression_list =
    [expression] { ',' [expression] };

expression_list =
    expression { ',' expression };

array_subscripts =
    '[' subscript { ',' subscript } ']';

subscript =
    ':' | expression;

comment =
    string_comment [annotation];

string_comment =
    [ STRING { '+' STRING } ];

annotation =
    'annotation' class_modification;

re_IDENT = ?/[_a-zA-Z][_a-zA-Z0-9]*/?;
re_STRING = ?/"[^"]+"/?;
re_UNSIGNED_NUMBER = ?/[0-9]+([\.] [0-9]+)?[[eE][\+\-]?[0-9]+/?;

(* creating rules so whitespace skipped *)
IDENT = re_IDENT; 
STRING = re_STRING;
UNSIGNED_NUMBER = re_UNSIGNED_NUMBER;


(*
vi:ts=4:sw=4:expandtab:
*)
