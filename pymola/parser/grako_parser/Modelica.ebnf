(* B.2.1 Stored Definition -Within *)

stored_definition =
    [ 'within'   within:[name] ';' ]
    { [final:'final'] class_definition:class_definition ';'}+;
    (* forcing one class with + so we get useful debugging*)

(* B.2.2 Class Definition *)

class_definition =
    [encapsulated:'encapsulated']
    class_prefixes:class_prefixes
    class_specifier:class_specifier;

class_prefixes =
    [partial:'partial']
    type:( 'class' | 'model' | ['operator'] 'record' | 'block' 
    | ['expandable'] 'connector' | 'type' | 'package' | 
    [('pure'|'impure')] ['operator'] 
    'function' | 'operator' );

class_specifier =
    @:(class_specifier_long |
    class_specifier_short |
    class_specifier_enum |
    class_specifier_der |
    class_specifier_extends) ;

class_specifier_long =
    name:IDENT
    comment:string_comment
    composition:composition 
    'end'  name_check:IDENT;

class_specifier_short =
    name:IDENT '='
    base_prefix:base_prefix
    base_name:name
    [array_subscripts:array_subscripts]
    [class_modification:class_modification]
    comment:comment;

class_specifier_enum =
    name:IDENT
    '=' 'enumeration' 
    '(' enumeration: ( [enum_list] | ':' ) ')'
    comment:comment;

class_specifier_der =
    name:IDENT '=' 'der'  '(' var_name:name ','
    id:IDENT { ',' id:IDENT } ')' comment:comment;

class_specifier_extends =
    'extends'  name:IDENT
    class_modification:[class_modification]
    comment:string_comment composition:composition
    'end'  name_check:IDENT;

base_prefix =
    type_prefix;

enum_list = @:enumeration_literal { ',' @:enumeration_literal};

enumeration_literal = name:IDENT comment:comment;

composition =
    element_list:element_list
    { access:'public'  element_list:element_list |
      access:'protected'  element_list:element_list |
      equation_section:equation_section |
      algorithm_section:algorithm_section
    }
    [ 'external'  [language_specification:language_specification]
               [function_call:external_function_call]
               [function_call_anotation:annotation] ';' ]
    [ annotation:annotation ';' ] ;

language_specification =
    @:STRING;

external_function_call =
    [ @+:component_reference '=' ]
    @+:IDENT '(' [@+:expression_list] ')' ;

element_list =
    { @+:element  ';' } ;

element =
    import_clause |
    extends_clause |
    [redeclare:'redeclare']
    [final:'final']
    [inner:'inner']
    [outer:'outer']
    ( definition:( class_definition | component_clause) |
    replaceable:'replaceable'
    defnition:( class_definition | component_clause)
    [constraining_clause comment:comment]) ;

import_clause =
    'import' ( alias:IDENT '=' name:name | name:name ['.' ( '*' | 
    '{' import:import_list '}' ) ] ) comment:comment ;

import_list =
    alias:IDENT [ ',' list:import_list ] ;

(* B.2.3 Extends *)

extends_clause =
    'extends'  name [class_modification:class_modification]
    [annotation:annotation];

constraining_clause =
    'constrainedby'  name:name [modification:class_modification];

(* B.2.4 Component Clause *)

component_clause = type_prefix:type_prefix
	type_specifier:type_specifier
	[array_subscripts:array_subscripts]
    component_list:component_list;

type_prefix =
    [flow_type:('flow'|'stream')]
    [value_type:('discrete'|'parameter'|'constant')]
    [io_type:'input'|'output'];

type_specifier =
    @:name;

component_list =
    @:component_declaration { ',' @:component_declaration } ;

component_declaration =
    @:declaration condition:[condition_attribute] comment:comment ;

condition_attribute =
    'if' @:expression ;

declaration =
    name:IDENT [array_subscripts:array_subscripts]
    [modification:modification] ;

(* B.2.5 Modification *)

modification =
    (class_modification:class_modification
        [ op:'='  expression:expression ])
    | op:'='  expression:expression
    | op:':='  expression:expression;

class_modification =
    '('  [@:argument_list] ')';

argument_list =
    @:argument { ',' @:argument } ;

argument =
    @:element_modification_or_replaceable
    | @:element_redeclaration ;

element_modification_or_replaceable =
    each:['each'] final:['final']
    @:(element_modification |
     element_replaceable);

element_modification =
    name:name @:[modification] comment:string_comment;

element_redeclaration =
    'redeclare'  [each:'each'] [final:'final']
    @:( ( short_class_definition |
        component_clause1) | 
        element_replaceable );

element_replaceable =
    'replaceable'  @:( short_class_definition |
    component_clause1)
    [constraining_clause:constraining_clause];

component_clause1 =
    type_prefix:type_prefix
    type_specifier:type_specifier
    @:component_declaration1;

component_declaration1 =
    @:declaration comment:comment;

short_class_definition =
    class_prefixes:class_prefixes IDENT '='
    ( base_prefix:base_prefix base_name:name
    [array_subscripts:array_subscripts]
    [@:class_modification]
    comment:comment |
    'enumeration' '(' ( [enum_list:enum_list] | ':' ) ')'
    comment:comment );

(* B.2.6 Equations *)

equation_section =
    initial:['initial'] 'equation'  { equation:equation  ';' };

algorithm_section =
    initial:['initial'] 'algorithm'  { statement:statement  ';' };

equation =
    ( lhs:simple_expression '='  rhs:expression
    | @:if_equation
    | @:for_equation
    | @:connect_clause
    | @:when_equation
    | function_name:name call_args:function_call_args )
    comment ;

statement =
    def:( component:component_reference  ( ':='  expression:expression | call_args:function_call_args )
    | '('  lhs:output_expression_list ')' ':='  rhs_component:component_reference rhs_call_args:function_call_args
    | 'break'
    | 'return'
    | if_statement
    | for_statement
    | while_statement
    | when_statement )
    comment:comment ;

if_equation =
    'if' if_cond:expression 'then'
    { if_then:equation  ';' }
    { 'elseif' elseif_cond:expression 'then'
    { elseif_then:equation ';' }
    }
    [ 'else'
    { else_then:equation ';' }
    ]
    'end' 'if' ;

if_statement =
    'if' if_cond:expression 'then'
    { if_then:statement  ';' }
    { 'elseif' elseif_cond:expression 'then'
    { elseif_then:statement ';' }
    }
    [ 'else'
    { else_then:statement ';' }
    ]
    'end' 'if';

for_equation =
    'for' for_indices:for_indices 'loop'
    { equations:equation  ';' }
    'end' 'for';

for_statement =
    'for' for_indices:for_indices 'loop'
    { statements:statement  ';' }
    'end' 'for';

for_indices =
    @:for_index {','  @:for_index};

for_index =
    @:IDENT [ 'in' in:expression ];

while_statement =
    'while' while_cond:expression 'loop'
    { while_statement:statement ';' }
    'end' 'while';

when_equation =
    'when' when_cond:expression 'then'
    { when_then:equation ';' }
    { 'elsewhen' elsewhen_cond:expression 'then'
    { elsewhen_then:equation ';' } }
    'end' 'when';

when_statement =
    'when' when_cond:expression 'then'
    { when_then:statement ';' }
    { 'elsewhen' else_cond:expression 'then'
    { elsewhen_then:statement ';' } }
    'end' 'when';

connect_clause =
    'connect' '(' connect_a:component_reference ',' connect_b:component_reference ')';

(* B.2.7 Expression *)

expression =
    @:simple_expression
    | ('if' if_cond:expression 'then' if_then:expression
    { 'elseif' elseif_cond:expression 'then' elseif_then:expression }
    'else' else_then:expression);

simple_expression =
    (@:logical_expression
    [ ':' @:logical_expression [ ':' @:logical_expression ] ]);

logical_expression =
    (@:logical_term { op:'or' @:logical_term });

logical_term =
    (@:logical_factor { op:'and' @:logical_factor });

logical_factor =
    [not:'not'] @:relation;

relation =
    (@:arithmetic_expression [ rel_op:rel_op @:arithmetic_expression ]);

rel_op =
    @:('<' | '<=' | '>' | '>=' | '==' | '<>');

arithmetic_expression =
    [add_op:add_op] @:term { add_op:add_op @:term };

add_op =
    @:('+' | '-' | '.+' | '.-');

term =
    @:factor { mul_op:mul_op @:factor };

mul_op =
    @:('*' | '/' | '.*' | './');

factor =
    @:primary [ ('^' | '.^') exponent:primary ];

primary =
    @:UNSIGNED_NUMBER
    | @:STRING
    | @:'false'
    | @:'true'
    | type:( name | 'der' | 'initial' ) call_args:function_call_args
    | @:component_reference
    | '(' @:output_expression_list ')'
    | '[' @:expression_list { ';' @:expression_list } ']'
    | '{' @:function_arguments '}'
    | @:'end';

name =
    [ '.' ] @:IDENT { '.' @:IDENT };

component_reference =
    [ '.' ] @:IDENT [ array_subscripts:array_subscripts ] { '.' @:IDENT [ array_subscripts:array_subscripts ] };

function_call_args =
    '(' [@:function_arguments] ')';

function_arguments =
    @:function_argument [ ',' @:function_arguments | 'for' @:for_indices ]
    | @:named_arguments;

named_arguments = @:named_argument [ ',' @:named_arguments ];

named_argument = name:IDENT '=' @:function_argument;

function_argument =
    'function' name:name '(' [@:named_arguments] ')' | @:expression;

output_expression_list =
    [@:expression] { ',' [@:expression] };

expression_list =
    @:expression { ',' @:expression };

array_subscripts =
    '[' @:subscript { ',' @:subscript } ']';

subscript =
    @:(':' | expression);

comment =
    @:string_comment annotation:[annotation];

string_comment =
    @:[ STRING { '+' STRING } ];

annotation =
    'annotation' @:class_modification;

re_IDENT = @:?/[_a-zA-Z][_a-zA-Z0-9]*/?;
re_STRING = @:?/"[^"]+"/?;
re_UNSIGNED_NUMBER = @:?/[0-9]+([\.][0-9]+)?([eE][\+\-]?[0-9]+)?/?;

(* creating rules so whitespace skipped *)
IDENT = @:re_IDENT; 
STRING = @:re_STRING;
UNSIGNED_NUMBER = @:re_UNSIGNED_NUMBER;


(*
vi:ts=4:sw=4:expandtab:
*)
