#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import graken, Parser


__version__ = (2015, 1, 4, 1, 59, 41, 6)

__all__ = [
    'ModelicaParser',
    'ModelicaSemantics',
    'main'
]


class ModelicaParser(Parser):
    def __init__(self, whitespace=None, nameguard=True, **kwargs):
        super(ModelicaParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            **kwargs
        )

    @graken()
    def _stored_definition_(self):
        with self._optional():
            self._token('within')
            self._cut()
            with self._optional():
                self._name_()
            self.ast['within'] = self.last_node
            self._token(';')

        def block1():
            with self._optional():
                self._token('final')
                self.ast['final'] = self.last_node
            self._class_definition_()
            self.ast['class_definition'] = self.last_node
            self._token(';')
        self._positive_closure(block1)

        self.ast._define(
            ['within', 'final', 'class_definition'],
            []
        )

    @graken()
    def _class_definition_(self):
        with self._optional():
            self._token('encapsulated')
            self.ast['encapsulated'] = self.last_node
        self._class_prefixes_()
        self.ast['class_prefixes'] = self.last_node
        self._class_specifier_()
        self.ast['class_specifier'] = self.last_node

        self.ast._define(
            ['encapsulated', 'class_prefixes', 'class_specifier'],
            []
        )

    @graken()
    def _class_prefixes_(self):
        with self._optional():
            self._token('partial')
            self.ast['partial'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    self._token('class')
                with self._option():
                    self._token('model')
                with self._option():
                    with self._optional():
                        self._token('operator')
                    self._token('record')
                with self._option():
                    self._token('block')
                with self._option():
                    with self._optional():
                        self._token('expandable')
                    self._token('connector')
                with self._option():
                    self._token('type')
                with self._option():
                    self._token('package')
                with self._option():
                    with self._optional():
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('pure')
                                with self._option():
                                    self._token('impure')
                                self._error('expecting one of: impure pure')
                    with self._optional():
                        self._token('operator')
                    self._token('function')
                with self._option():
                    self._token('operator')
                self._error('expecting one of: block class connector expandable function impure model operator package pure record type')
        self.ast['type'] = self.last_node

        self.ast._define(
            ['partial', 'type'],
            []
        )

    @graken()
    def _class_specifier_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._class_specifier_long_()
                with self._option():
                    self._class_specifier_short_()
                with self._option():
                    self._class_specifier_enum_()
                with self._option():
                    self._class_specifier_der_()
                with self._option():
                    self._class_specifier_extends_()
                self._error('no available options')
        self.ast['@'] = self.last_node

    @graken()
    def _class_specifier_long_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._string_comment_()
        self.ast['comment'] = self.last_node
        self._composition_()
        self.ast['composition'] = self.last_node
        self._token('end')
        self._cut()
        self._IDENT_()
        self.ast['name_check'] = self.last_node

        self.ast._define(
            ['name', 'comment', 'composition', 'name_check'],
            []
        )

    @graken()
    def _class_specifier_short_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._token('=')
        self._base_prefix_()
        self.ast['base_prefix'] = self.last_node
        self._name_()
        self.ast['base_name'] = self.last_node
        with self._optional():
            self._array_subscripts_()
            self.ast['array_subscripts'] = self.last_node
        with self._optional():
            self._class_modification_()
            self.ast['class_modification'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['name', 'base_prefix', 'base_name', 'array_subscripts', 'class_modification', 'comment'],
            []
        )

    @graken()
    def _class_specifier_enum_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._token('=')
        self._token('enumeration')
        self._token('(')
        with self._group():
            with self._choice():
                with self._option():
                    with self._optional():
                        self._enum_list_()
                with self._option():
                    self._token(':')
                self._error('expecting one of: :')
        self.ast['enumeration'] = self.last_node
        self._token(')')
        self._comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['name', 'enumeration', 'comment'],
            []
        )

    @graken()
    def _class_specifier_der_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._token('=')
        self._token('der')
        self._token('(')
        self._name_()
        self.ast['var_name'] = self.last_node
        self._token(',')
        self._IDENT_()
        self.ast['id'] = self.last_node

        def block3():
            self._token(',')
            self._IDENT_()
            self.ast['id'] = self.last_node
        self._closure(block3)
        self._token(')')
        self._comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['name', 'var_name', 'id', 'comment'],
            []
        )

    @graken()
    def _class_specifier_extends_(self):
        self._token('extends')
        self._IDENT_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._class_modification_()
        self.ast['class_modification'] = self.last_node
        self._string_comment_()
        self.ast['comment'] = self.last_node
        self._composition_()
        self.ast['composition'] = self.last_node
        self._token('end')
        self._cut()
        self._IDENT_()
        self.ast['name_check'] = self.last_node

        self.ast._define(
            ['name', 'class_modification', 'comment', 'composition', 'name_check'],
            []
        )

    @graken()
    def _base_prefix_(self):
        self._type_prefix_()

    @graken()
    def _enum_list_(self):
        self._enumeration_literal_()
        self.ast.setlist('@', self.last_node)

        def block1():
            self._token(',')
            self._enumeration_literal_()
            self.ast.setlist('@', self.last_node)
        self._closure(block1)

    @graken()
    def _enumeration_literal_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['name', 'comment'],
            []
        )

    @graken()
    def _composition_(self):
        self._element_list_()
        self.ast['element_list'] = self.last_node

        def block1():
            with self._choice():
                with self._option():
                    self._token('public')
                    self.ast['access'] = self.last_node
                    self._element_list_()
                    self.ast['element_list'] = self.last_node
                with self._option():
                    self._token('protected')
                    self.ast['access'] = self.last_node
                    self._element_list_()
                    self.ast['element_list'] = self.last_node
                with self._option():
                    self._equation_section_()
                    self.ast['equation_section'] = self.last_node
                with self._option():
                    self._algorithm_section_()
                    self.ast['algorithm_section'] = self.last_node
                self._error('no available options')
        self._closure(block1)
        with self._optional():
            self._token('external')
            with self._optional():
                self._language_specification_()
                self.ast['language_specification'] = self.last_node
            with self._optional():
                self._external_function_call_()
                self.ast['function_call'] = self.last_node
            with self._optional():
                self._annotation_()
                self.ast['function_call_anotation'] = self.last_node
            self._token(';')
        with self._optional():
            self._annotation_()
            self.ast['annotation'] = self.last_node
            self._token(';')

        self.ast._define(
            ['element_list', 'access', 'equation_section', 'algorithm_section', 'language_specification', 'function_call', 'function_call_anotation', 'annotation'],
            []
        )

    @graken()
    def _language_specification_(self):
        self._STRING_()
        self.ast['@'] = self.last_node

    @graken()
    def _external_function_call_(self):
        with self._optional():
            self._component_reference_()
            self.ast.setlist('@', self.last_node)
            self._token('=')
        self._IDENT_()
        self.ast.setlist('@', self.last_node)
        self._token('(')
        with self._optional():
            self._expression_list_()
            self.ast.setlist('@', self.last_node)
        self._token(')')

    @graken()
    def _element_list_(self):

        def block0():
            self._element_()
            self.ast.setlist('@', self.last_node)
            self._cut()
            self._token(';')
        self._closure(block0)

    @graken()
    def _element_(self):
        with self._choice():
            with self._option():
                self._import_clause_()
            with self._option():
                self._extends_clause_()
            with self._option():
                with self._optional():
                    self._token('redeclare')
                    self.ast['redeclare'] = self.last_node
                with self._optional():
                    self._token('final')
                    self.ast['final'] = self.last_node
                with self._optional():
                    self._token('inner')
                    self.ast['inner'] = self.last_node
                with self._optional():
                    self._token('outer')
                    self.ast['outer'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._class_definition_()
                                    with self._option():
                                        self._component_clause_()
                                    self._error('no available options')
                            self.ast['definition'] = self.last_node
                        with self._option():
                            self._token('replaceable')
                            self.ast['replaceable'] = self.last_node
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._class_definition_()
                                    with self._option():
                                        self._component_clause_()
                                    self._error('no available options')
                            self.ast['defnition'] = self.last_node
                            with self._optional():
                                self._constraining_clause_()
                                self._comment_()
                                self.ast['comment'] = self.last_node
                        self._error('no available options')
            self._error('no available options')

        self.ast._define(
            ['redeclare', 'final', 'inner', 'outer', 'definition', 'replaceable', 'defnition', 'comment'],
            []
        )

    @graken()
    def _import_clause_(self):
        self._token('import')
        with self._group():
            with self._choice():
                with self._option():
                    self._IDENT_()
                    self.ast['alias'] = self.last_node
                    self._token('=')
                    self._name_()
                    self.ast['name'] = self.last_node
                with self._option():
                    self._name_()
                    self.ast['name'] = self.last_node
                    with self._optional():
                        self._token('.')
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('*')
                                with self._option():
                                    self._token('{')
                                    self._import_list_()
                                    self.ast['import_'] = self.last_node
                                    self._token('}')
                                self._error('expecting one of: *')
                self._error('no available options')
        self._comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['alias', 'name', 'import', 'comment'],
            []
        )

    @graken()
    def _import_list_(self):
        self._IDENT_()
        self.ast['alias'] = self.last_node
        with self._optional():
            self._token(',')
            self._import_list_()
            self.ast['list'] = self.last_node

        self.ast._define(
            ['alias', 'list'],
            []
        )

    @graken()
    def _extends_clause_(self):
        self._token('extends')
        self._name_()
        with self._optional():
            self._class_modification_()
            self.ast['class_modification'] = self.last_node
        with self._optional():
            self._annotation_()
            self.ast['annotation'] = self.last_node

        self.ast._define(
            ['class_modification', 'annotation'],
            []
        )

    @graken()
    def _constraining_clause_(self):
        self._token('constrainedby')
        self._name_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._class_modification_()
            self.ast['modification'] = self.last_node

        self.ast._define(
            ['name', 'modification'],
            []
        )

    @graken()
    def _component_clause_(self):
        self._type_prefix_()
        self.ast['type_prefix'] = self.last_node
        self._type_specifier_()
        self.ast['type_specifier'] = self.last_node
        with self._optional():
            self._array_subscripts_()
            self.ast['array_subscripts'] = self.last_node
        self._component_list_()
        self.ast['component_list'] = self.last_node

        self.ast._define(
            ['type_prefix', 'type_specifier', 'array_subscripts', 'component_list'],
            []
        )

    @graken()
    def _type_prefix_(self):
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('flow')
                    with self._option():
                        self._token('stream')
                    self._error('expecting one of: flow stream')
            self.ast['flow_type'] = self.last_node
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('discrete')
                    with self._option():
                        self._token('parameter')
                    with self._option():
                        self._token('constant')
                    self._error('expecting one of: constant discrete parameter')
            self.ast['value_type'] = self.last_node
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('input')
                    self.ast['io_type'] = self.last_node
                with self._option():
                    self._token('output')
                self._error('expecting one of: input output')

        self.ast._define(
            ['flow_type', 'value_type', 'io_type'],
            []
        )

    @graken()
    def _type_specifier_(self):
        self._name_()
        self.ast['@'] = self.last_node

    @graken()
    def _component_list_(self):
        self._component_declaration_()
        self.ast['@'] = self.last_node

        def block1():
            self._token(',')
            self._component_declaration_()
            self.ast['@'] = self.last_node
        self._closure(block1)

    @graken()
    def _component_declaration_(self):
        self._declaration_()
        self.ast['@'] = self.last_node
        with self._optional():
            self._condition_attribute_()
        self.ast['condition'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['condition', 'comment'],
            []
        )

    @graken()
    def _condition_attribute_(self):
        self._token('if')
        self._expression_()
        self.ast['@'] = self.last_node

    @graken()
    def _declaration_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._array_subscripts_()
            self.ast['array_subscripts'] = self.last_node
        with self._optional():
            self._modification_()
            self.ast['modification'] = self.last_node

        self.ast._define(
            ['name', 'array_subscripts', 'modification'],
            []
        )

    @graken()
    def _modification_(self):
        with self._choice():
            with self._option():
                with self._group():
                    self._class_modification_()
                    self.ast['class_modification'] = self.last_node
                    with self._optional():
                        self._token('=')
                        self.ast['op'] = self.last_node
                        self._cut()
                        self._expression_()
                        self.ast['expression'] = self.last_node
            with self._option():
                self._token('=')
                self.ast['op'] = self.last_node
                self._cut()
                self._expression_()
                self.ast['expression'] = self.last_node
            with self._option():
                self._token(':=')
                self.ast['op'] = self.last_node
                self._cut()
                self._expression_()
                self.ast['expression'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['class_modification', 'op', 'expression'],
            []
        )

    @graken()
    def _class_modification_(self):
        self._token('(')
        self._cut()
        with self._optional():
            self._argument_list_()
            self.ast['@'] = self.last_node
        self._token(')')

    @graken()
    def _argument_list_(self):
        self._argument_()
        self.ast.setlist('@', self.last_node)

        def block1():
            self._token(',')
            self._argument_()
            self.ast.setlist('@', self.last_node)
        self._closure(block1)

    @graken()
    def _argument_(self):
        with self._choice():
            with self._option():
                self._element_modification_or_replaceable_()
                self.ast['@'] = self.last_node
            with self._option():
                self._element_redeclaration_()
                self.ast['@'] = self.last_node
            self._error('no available options')

    @graken()
    def _element_modification_or_replaceable_(self):
        with self._optional():
            self._token('each')
        self.ast['each'] = self.last_node
        with self._optional():
            self._token('final')
        self.ast['final'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    self._element_modification_()
                with self._option():
                    self._element_replaceable_()
                self._error('no available options')
        self.ast['@'] = self.last_node

        self.ast._define(
            ['each', 'final'],
            []
        )

    @graken()
    def _element_modification_(self):
        self._name_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._modification_()
        self.ast['@'] = self.last_node
        self._string_comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['name', 'comment'],
            []
        )

    @graken()
    def _element_redeclaration_(self):
        self._token('redeclare')
        with self._optional():
            self._token('each')
            self.ast['each'] = self.last_node
        with self._optional():
            self._token('final')
            self.ast['final'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._short_class_definition_()
                            with self._option():
                                self._component_clause1_()
                            self._error('no available options')
                with self._option():
                    self._element_replaceable_()
                self._error('no available options')
        self.ast['@'] = self.last_node

        self.ast._define(
            ['each', 'final'],
            []
        )

    @graken()
    def _element_replaceable_(self):
        self._token('replaceable')
        with self._group():
            with self._choice():
                with self._option():
                    self._short_class_definition_()
                with self._option():
                    self._component_clause1_()
                self._error('no available options')
        self.ast['@'] = self.last_node
        with self._optional():
            self._constraining_clause_()
            self.ast['constraining_clause'] = self.last_node

        self.ast._define(
            ['constraining_clause'],
            []
        )

    @graken()
    def _component_clause1_(self):
        self._type_prefix_()
        self.ast['type_prefix'] = self.last_node
        self._type_specifier_()
        self.ast['type_specifier'] = self.last_node
        self._component_declaration1_()
        self.ast['@'] = self.last_node

        self.ast._define(
            ['type_prefix', 'type_specifier'],
            []
        )

    @graken()
    def _component_declaration1_(self):
        self._declaration_()
        self.ast['@'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['comment'],
            []
        )

    @graken()
    def _short_class_definition_(self):
        self._class_prefixes_()
        self.ast['class_prefixes'] = self.last_node
        self._IDENT_()
        self._token('=')
        with self._group():
            with self._choice():
                with self._option():
                    self._base_prefix_()
                    self.ast['base_prefix'] = self.last_node
                    self._name_()
                    self.ast['base_name'] = self.last_node
                    with self._optional():
                        self._array_subscripts_()
                        self.ast['array_subscripts'] = self.last_node
                    with self._optional():
                        self._class_modification_()
                        self.ast['@'] = self.last_node
                    self._comment_()
                    self.ast['comment'] = self.last_node
                with self._option():
                    self._token('enumeration')
                    self._token('(')
                    with self._group():
                        with self._choice():
                            with self._option():
                                with self._optional():
                                    self._enum_list_()
                                    self.ast['enum_list'] = self.last_node
                            with self._option():
                                self._token(':')
                            self._error('expecting one of: :')
                    self._token(')')
                    self._comment_()
                    self.ast['comment'] = self.last_node
                self._error('no available options')

        self.ast._define(
            ['class_prefixes', 'base_prefix', 'base_name', 'array_subscripts', 'comment', 'enum_list'],
            []
        )

    @graken()
    def _equation_section_(self):
        with self._optional():
            self._token('initial')
        self.ast['initial'] = self.last_node
        self._token('equation')
        self._cut()

        def block1():
            self._equation_()
            self.ast['equation'] = self.last_node
            self._cut()
            self._token(';')
        self._closure(block1)

        self.ast._define(
            ['initial', 'equation'],
            []
        )

    @graken()
    def _algorithm_section_(self):
        with self._optional():
            self._token('initial')
        self.ast['initial'] = self.last_node
        self._token('algorithm')
        self._cut()

        def block1():
            self._statement_()
            self.ast['statement'] = self.last_node
            self._cut()
            self._token(';')
        self._closure(block1)

        self.ast._define(
            ['initial', 'statement'],
            []
        )

    @graken()
    def _equation_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._simple_expression_()
                    self.ast['lhs'] = self.last_node
                    self._token('=')
                    self._cut()
                    self._expression_()
                    self.ast['rhs'] = self.last_node
                with self._option():
                    self._if_equation_()
                    self.ast['@'] = self.last_node
                with self._option():
                    self._for_equation_()
                    self.ast['@'] = self.last_node
                with self._option():
                    self._connect_clause_()
                    self.ast['@'] = self.last_node
                with self._option():
                    self._when_equation_()
                    self.ast['@'] = self.last_node
                with self._option():
                    self._name_()
                    self.ast['function_name'] = self.last_node
                    self._function_call_args_()
                    self.ast['call_args'] = self.last_node
                self._error('no available options')
        self._comment_()

        self.ast._define(
            ['lhs', 'rhs', 'function_name', 'call_args'],
            []
        )

    @graken()
    def _statement_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._component_reference_()
                    self.ast['component'] = self.last_node
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token(':=')
                                self._cut()
                                self._expression_()
                                self.ast['expression'] = self.last_node
                            with self._option():
                                self._function_call_args_()
                                self.ast['call_args'] = self.last_node
                            self._error('no available options')
                with self._option():
                    self._token('(')
                    self._output_expression_list_()
                    self.ast['lhs'] = self.last_node
                    self._token(')')
                    self._token(':=')
                    self._cut()
                    self._component_reference_()
                    self.ast['rhs_component'] = self.last_node
                    self._function_call_args_()
                    self.ast['rhs_call_args'] = self.last_node
                with self._option():
                    self._token('break')
                with self._option():
                    self._token('return')
                with self._option():
                    self._if_statement_()
                with self._option():
                    self._for_statement_()
                with self._option():
                    self._while_statement_()
                with self._option():
                    self._when_statement_()
                self._error('expecting one of: break return')
        self.ast['def_'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

        self.ast._define(
            ['def', 'component', 'expression', 'call_args', 'lhs', 'rhs_component', 'rhs_call_args', 'comment'],
            []
        )

    @graken()
    def _if_equation_(self):
        self._token('if')
        self._expression_()
        self.ast['if_cond'] = self.last_node
        self._token('then')

        def block1():
            self._equation_()
            self.ast['if_then'] = self.last_node
            self._token(';')
        self._closure(block1)

        def block3():
            self._token('elseif')
            self._expression_()
            self.ast['elseif_cond'] = self.last_node
            self._token('then')

            def block5():
                self._equation_()
                self.ast['elseif_then'] = self.last_node
                self._token(';')
            self._closure(block5)
        self._closure(block3)
        with self._optional():
            self._token('else')

            def block7():
                self._equation_()
                self.ast['else_then'] = self.last_node
                self._token(';')
            self._closure(block7)
        self._token('end')
        self._token('if')

        self.ast._define(
            ['if_cond', 'if_then', 'elseif_cond', 'elseif_then', 'else_then'],
            []
        )

    @graken()
    def _if_statement_(self):
        self._token('if')
        self._expression_()
        self.ast['if_cond'] = self.last_node
        self._token('then')

        def block1():
            self._statement_()
            self.ast['if_then'] = self.last_node
            self._token(';')
        self._closure(block1)

        def block3():
            self._token('elseif')
            self._expression_()
            self.ast['elseif_cond'] = self.last_node
            self._token('then')

            def block5():
                self._statement_()
                self.ast['elseif_then'] = self.last_node
                self._token(';')
            self._closure(block5)
        self._closure(block3)
        with self._optional():
            self._token('else')

            def block7():
                self._statement_()
                self.ast['else_then'] = self.last_node
                self._token(';')
            self._closure(block7)
        self._token('end')
        self._token('if')

        self.ast._define(
            ['if_cond', 'if_then', 'elseif_cond', 'elseif_then', 'else_then'],
            []
        )

    @graken()
    def _for_equation_(self):
        self._token('for')
        self._for_indices_()
        self.ast['for_indices'] = self.last_node
        self._token('loop')

        def block1():
            self._equation_()
            self.ast['equations'] = self.last_node
            self._token(';')
        self._closure(block1)
        self._token('end')
        self._token('for')

        self.ast._define(
            ['for_indices', 'equations'],
            []
        )

    @graken()
    def _for_statement_(self):
        self._token('for')
        self._for_indices_()
        self.ast['for_indices'] = self.last_node
        self._token('loop')

        def block1():
            self._statement_()
            self.ast['statements'] = self.last_node
            self._token(';')
        self._closure(block1)
        self._token('end')
        self._token('for')

        self.ast._define(
            ['for_indices', 'statements'],
            []
        )

    @graken()
    def _for_indices_(self):
        self._for_index_()
        self.ast['@'] = self.last_node

        def block1():
            self._token(',')
            self._for_index_()
            self.ast['@'] = self.last_node
        self._closure(block1)

    @graken()
    def _for_index_(self):
        self._IDENT_()
        self.ast['@'] = self.last_node
        with self._optional():
            self._token('in')
            self._expression_()
            self.ast['in_'] = self.last_node

        self.ast._define(
            ['in'],
            []
        )

    @graken()
    def _while_statement_(self):
        self._token('while')
        self._expression_()
        self.ast['while_cond'] = self.last_node
        self._token('loop')

        def block1():
            self._statement_()
            self.ast['while_statement'] = self.last_node
            self._token(';')
        self._closure(block1)
        self._token('end')
        self._token('while')

        self.ast._define(
            ['while_cond', 'while_statement'],
            []
        )

    @graken()
    def _when_equation_(self):
        self._token('when')
        self._expression_()
        self.ast['when_cond'] = self.last_node
        self._token('then')

        def block1():
            self._equation_()
            self.ast['when_then'] = self.last_node
            self._token(';')
        self._closure(block1)

        def block3():
            self._token('elsewhen')
            self._expression_()
            self.ast['elsewhen_cond'] = self.last_node
            self._token('then')

            def block5():
                self._equation_()
                self.ast['elsewhen_then'] = self.last_node
                self._token(';')
            self._closure(block5)
        self._closure(block3)
        self._token('end')
        self._token('when')

        self.ast._define(
            ['when_cond', 'when_then', 'elsewhen_cond', 'elsewhen_then'],
            []
        )

    @graken()
    def _when_statement_(self):
        self._token('when')
        self._expression_()
        self.ast['when_cond'] = self.last_node
        self._token('then')

        def block1():
            self._statement_()
            self.ast['when_then'] = self.last_node
            self._token(';')
        self._closure(block1)

        def block3():
            self._token('elsewhen')
            self._expression_()
            self.ast['else_cond'] = self.last_node
            self._token('then')

            def block5():
                self._statement_()
                self.ast['elsewhen_then'] = self.last_node
                self._token(';')
            self._closure(block5)
        self._closure(block3)
        self._token('end')
        self._token('when')

        self.ast._define(
            ['when_cond', 'when_then', 'else_cond', 'elsewhen_then'],
            []
        )

    @graken()
    def _connect_clause_(self):
        self._token('connect')
        self._token('(')
        self._component_reference_()
        self.ast['connect_a'] = self.last_node
        self._token(',')
        self._component_reference_()
        self.ast['connect_b'] = self.last_node
        self._token(')')

        self.ast._define(
            ['connect_a', 'connect_b'],
            []
        )

    @graken()
    def _expression_(self):
        with self._choice():
            with self._option():
                self._simple_expression_()
                self.ast['@'] = self.last_node
            with self._option():
                with self._group():
                    self._token('if')
                    self._expression_()
                    self.ast['if_cond'] = self.last_node
                    self._token('then')
                    self._expression_()
                    self.ast['if_then'] = self.last_node

                    def block3():
                        self._token('elseif')
                        self._expression_()
                        self.ast['elseif_cond'] = self.last_node
                        self._token('then')
                        self._expression_()
                        self.ast['elseif_then'] = self.last_node
                    self._closure(block3)
                    self._token('else')
                    self._expression_()
                    self.ast['else_then'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['if_cond', 'if_then', 'elseif_cond', 'elseif_then', 'else_then'],
            []
        )

    @graken()
    def _simple_expression_(self):
        with self._group():
            self._logical_expression_()
            self.ast['@'] = self.last_node
            with self._optional():
                self._token(':')
                self._logical_expression_()
                self.ast['@'] = self.last_node
                with self._optional():
                    self._token(':')
                    self._logical_expression_()
                    self.ast['@'] = self.last_node

    @graken()
    def _logical_expression_(self):
        with self._group():
            self._logical_term_()
            self.ast['@'] = self.last_node

            def block1():
                self._token('or')
                self.ast['op'] = self.last_node
                self._logical_term_()
                self.ast['@'] = self.last_node
            self._closure(block1)

        self.ast._define(
            ['op'],
            []
        )

    @graken()
    def _logical_term_(self):
        with self._group():
            self._logical_factor_()
            self.ast['@'] = self.last_node

            def block1():
                self._token('and')
                self.ast['op'] = self.last_node
                self._logical_factor_()
                self.ast['@'] = self.last_node
            self._closure(block1)

        self.ast._define(
            ['op'],
            []
        )

    @graken()
    def _logical_factor_(self):
        with self._optional():
            self._token('not')
            self.ast['not_'] = self.last_node
        self._relation_()
        self.ast['@'] = self.last_node

        self.ast._define(
            ['not'],
            []
        )

    @graken()
    def _relation_(self):
        with self._group():
            self._arithmetic_expression_()
            self.ast['@'] = self.last_node
            with self._optional():
                self._rel_op_()
                self.ast['rel_op'] = self.last_node
                self._arithmetic_expression_()
                self.ast['@'] = self.last_node

        self.ast._define(
            ['rel_op'],
            []
        )

    @graken()
    def _rel_op_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('<')
                with self._option():
                    self._token('<=')
                with self._option():
                    self._token('>')
                with self._option():
                    self._token('>=')
                with self._option():
                    self._token('==')
                with self._option():
                    self._token('<>')
                self._error('expecting one of: < <= <> == > >=')
        self.ast['@'] = self.last_node

    @graken()
    def _arithmetic_expression_(self):
        with self._optional():
            self._add_op_()
            self.ast['add_op'] = self.last_node
        self._term_()
        self.ast['@'] = self.last_node

        def block2():
            self._add_op_()
            self.ast['add_op'] = self.last_node
            self._term_()
            self.ast['@'] = self.last_node
        self._closure(block2)

        self.ast._define(
            ['add_op'],
            []
        )

    @graken()
    def _add_op_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                with self._option():
                    self._token('.+')
                with self._option():
                    self._token('.-')
                self._error('expecting one of: + - .+ .-')
        self.ast['@'] = self.last_node

    @graken()
    def _term_(self):
        self._factor_()
        self.ast['@'] = self.last_node

        def block1():
            self._mul_op_()
            self.ast['mul_op'] = self.last_node
            self._factor_()
            self.ast['@'] = self.last_node
        self._closure(block1)

        self.ast._define(
            ['mul_op'],
            []
        )

    @graken()
    def _mul_op_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('*')
                with self._option():
                    self._token('/')
                with self._option():
                    self._token('.*')
                with self._option():
                    self._token('./')
                self._error('expecting one of: * .* ./ /')
        self.ast['@'] = self.last_node

    @graken()
    def _factor_(self):
        self._primary_()
        self.ast['@'] = self.last_node
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('^')
                    with self._option():
                        self._token('.^')
                    self._error('expecting one of: .^ ^')
            self._primary_()
            self.ast['exponent'] = self.last_node

        self.ast._define(
            ['exponent'],
            []
        )

    @graken()
    def _primary_(self):
        with self._choice():
            with self._option():
                self._UNSIGNED_NUMBER_()
                self.ast['@'] = self.last_node
            with self._option():
                self._STRING_()
                self.ast['@'] = self.last_node
            with self._option():
                self._token('false')
                self.ast['@'] = self.last_node
            with self._option():
                self._token('true')
                self.ast['@'] = self.last_node
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._name_()
                        with self._option():
                            self._token('der')
                        with self._option():
                            self._token('initial')
                        self._error('expecting one of: der initial')
                self.ast['type'] = self.last_node
                self._function_call_args_()
                self.ast['call_args'] = self.last_node
            with self._option():
                self._component_reference_()
                self.ast['@'] = self.last_node
            with self._option():
                self._token('(')
                self._output_expression_list_()
                self.ast['@'] = self.last_node
                self._token(')')
            with self._option():
                self._token('[')
                self._expression_list_()
                self.ast['@'] = self.last_node

                def block10():
                    self._token(';')
                    self._expression_list_()
                    self.ast['@'] = self.last_node
                self._closure(block10)
                self._token(']')
            with self._option():
                self._token('{')
                self._function_arguments_()
                self.ast['@'] = self.last_node
                self._token('}')
            with self._option():
                self._token('end')
                self.ast['@'] = self.last_node
            self._error('expecting one of: end false true')

        self.ast._define(
            ['type', 'call_args'],
            []
        )

    @graken()
    def _name_(self):
        with self._optional():
            self._token('.')
        self._IDENT_()
        self.ast['@'] = self.last_node

        def block1():
            self._token('.')
            self._IDENT_()
            self.ast['@'] = self.last_node
        self._closure(block1)

    @graken()
    def _component_reference_(self):
        with self._optional():
            self._token('.')
        self._IDENT_()
        self.ast['@'] = self.last_node
        with self._optional():
            self._array_subscripts_()
            self.ast['array_subscripts'] = self.last_node

        def block2():
            self._token('.')
            self._IDENT_()
            self.ast['@'] = self.last_node
            with self._optional():
                self._array_subscripts_()
                self.ast['array_subscripts'] = self.last_node
        self._closure(block2)

        self.ast._define(
            ['array_subscripts'],
            []
        )

    @graken()
    def _function_call_args_(self):
        self._token('(')
        with self._optional():
            self._function_arguments_()
            self.ast['@'] = self.last_node
        self._token(')')

    @graken()
    def _function_arguments_(self):
        with self._choice():
            with self._option():
                self._function_argument_()
                self.ast['@'] = self.last_node
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token(',')
                            self._function_arguments_()
                            self.ast['@'] = self.last_node
                        with self._option():
                            self._token('for')
                            self._for_indices_()
                            self.ast['@'] = self.last_node
                        self._error('no available options')
            with self._option():
                self._named_arguments_()
                self.ast['@'] = self.last_node
            self._error('no available options')

    @graken()
    def _named_arguments_(self):
        self._named_argument_()
        self.ast['@'] = self.last_node
        with self._optional():
            self._token(',')
            self._named_arguments_()
            self.ast['@'] = self.last_node

    @graken()
    def _named_argument_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._token('=')
        self._function_argument_()
        self.ast['@'] = self.last_node

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _function_argument_(self):
        with self._choice():
            with self._option():
                self._token('function')
                self._name_()
                self.ast['name'] = self.last_node
                self._token('(')
                with self._optional():
                    self._named_arguments_()
                    self.ast['@'] = self.last_node
                self._token(')')
            with self._option():
                self._expression_()
                self.ast['@'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _output_expression_list_(self):
        with self._optional():
            self._expression_()
            self.ast['@'] = self.last_node

        def block1():
            self._token(',')
            with self._optional():
                self._expression_()
                self.ast['@'] = self.last_node
        self._closure(block1)

    @graken()
    def _expression_list_(self):
        self._expression_()
        self.ast['@'] = self.last_node

        def block1():
            self._token(',')
            self._expression_()
            self.ast['@'] = self.last_node
        self._closure(block1)

    @graken()
    def _array_subscripts_(self):
        self._token('[')
        self._subscript_()
        self.ast['@'] = self.last_node

        def block1():
            self._token(',')
            self._subscript_()
            self.ast['@'] = self.last_node
        self._closure(block1)
        self._token(']')

    @graken()
    def _subscript_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token(':')
                with self._option():
                    self._expression_()
                self._error('expecting one of: :')
        self.ast['@'] = self.last_node

    @graken()
    def _comment_(self):
        self._string_comment_()
        self.ast['@'] = self.last_node
        with self._optional():
            self._annotation_()
        self.ast['annotation'] = self.last_node

        self.ast._define(
            ['annotation'],
            []
        )

    @graken()
    def _string_comment_(self):
        with self._optional():
            self._STRING_()

            def block1():
                self._token('+')
                self._STRING_()
            self._closure(block1)
        self.ast['@'] = self.last_node

    @graken()
    def _annotation_(self):
        self._token('annotation')
        self._class_modification_()
        self.ast['@'] = self.last_node

    @graken()
    def _re_IDENT_(self):
        self._pattern(r'[_a-zA-Z][_a-zA-Z0-9]*')
        self.ast['@'] = self.last_node

    @graken()
    def _re_STRING_(self):
        self._pattern(r'"[^"]+"')
        self.ast['@'] = self.last_node

    @graken()
    def _re_UNSIGNED_NUMBER_(self):
        self._pattern(r'[0-9]+([\.][0-9]+)?([eE][\+\-]?[0-9]+)?')
        self.ast['@'] = self.last_node

    @graken()
    def _IDENT_(self):
        self._re_IDENT_()
        self.ast['@'] = self.last_node

    @graken()
    def _STRING_(self):
        self._re_STRING_()
        self.ast['@'] = self.last_node

    @graken()
    def _UNSIGNED_NUMBER_(self):
        self._re_UNSIGNED_NUMBER_()
        self.ast['@'] = self.last_node


class ModelicaSemantics(object):
    def stored_definition(self, ast):
        return ast

    def class_definition(self, ast):
        return ast

    def class_prefixes(self, ast):
        return ast

    def class_specifier(self, ast):
        return ast

    def class_specifier_long(self, ast):
        return ast

    def class_specifier_short(self, ast):
        return ast

    def class_specifier_enum(self, ast):
        return ast

    def class_specifier_der(self, ast):
        return ast

    def class_specifier_extends(self, ast):
        return ast

    def base_prefix(self, ast):
        return ast

    def enum_list(self, ast):
        return ast

    def enumeration_literal(self, ast):
        return ast

    def composition(self, ast):
        return ast

    def language_specification(self, ast):
        return ast

    def external_function_call(self, ast):
        return ast

    def element_list(self, ast):
        return ast

    def element(self, ast):
        return ast

    def import_clause(self, ast):
        return ast

    def import_list(self, ast):
        return ast

    def extends_clause(self, ast):
        return ast

    def constraining_clause(self, ast):
        return ast

    def component_clause(self, ast):
        return ast

    def type_prefix(self, ast):
        return ast

    def type_specifier(self, ast):
        return ast

    def component_list(self, ast):
        return ast

    def component_declaration(self, ast):
        return ast

    def condition_attribute(self, ast):
        return ast

    def declaration(self, ast):
        return ast

    def modification(self, ast):
        return ast

    def class_modification(self, ast):
        return ast

    def argument_list(self, ast):
        return ast

    def argument(self, ast):
        return ast

    def element_modification_or_replaceable(self, ast):
        return ast

    def element_modification(self, ast):
        return ast

    def element_redeclaration(self, ast):
        return ast

    def element_replaceable(self, ast):
        return ast

    def component_clause1(self, ast):
        return ast

    def component_declaration1(self, ast):
        return ast

    def short_class_definition(self, ast):
        return ast

    def equation_section(self, ast):
        return ast

    def algorithm_section(self, ast):
        return ast

    def equation(self, ast):
        return ast

    def statement(self, ast):
        return ast

    def if_equation(self, ast):
        return ast

    def if_statement(self, ast):
        return ast

    def for_equation(self, ast):
        return ast

    def for_statement(self, ast):
        return ast

    def for_indices(self, ast):
        return ast

    def for_index(self, ast):
        return ast

    def while_statement(self, ast):
        return ast

    def when_equation(self, ast):
        return ast

    def when_statement(self, ast):
        return ast

    def connect_clause(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def simple_expression(self, ast):
        return ast

    def logical_expression(self, ast):
        return ast

    def logical_term(self, ast):
        return ast

    def logical_factor(self, ast):
        return ast

    def relation(self, ast):
        return ast

    def rel_op(self, ast):
        return ast

    def arithmetic_expression(self, ast):
        return ast

    def add_op(self, ast):
        return ast

    def term(self, ast):
        return ast

    def mul_op(self, ast):
        return ast

    def factor(self, ast):
        return ast

    def primary(self, ast):
        return ast

    def name(self, ast):
        return ast

    def component_reference(self, ast):
        return ast

    def function_call_args(self, ast):
        return ast

    def function_arguments(self, ast):
        return ast

    def named_arguments(self, ast):
        return ast

    def named_argument(self, ast):
        return ast

    def function_argument(self, ast):
        return ast

    def output_expression_list(self, ast):
        return ast

    def expression_list(self, ast):
        return ast

    def array_subscripts(self, ast):
        return ast

    def subscript(self, ast):
        return ast

    def comment(self, ast):
        return ast

    def string_comment(self, ast):
        return ast

    def annotation(self, ast):
        return ast

    def re_IDENT(self, ast):
        return ast

    def re_STRING(self, ast):
        return ast

    def re_UNSIGNED_NUMBER(self, ast):
        return ast

    def IDENT(self, ast):
        return ast

    def STRING(self, ast):
        return ast

    def UNSIGNED_NUMBER(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None, nameguard=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = ModelicaParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace,
        nameguard=nameguard)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in ModelicaParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for Modelica.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-n', '--no-nameguard', action='store_true',
                        dest='no_nameguard',
                        help="disable the 'nameguard' feature")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(
        args.file,
        args.startrule,
        trace=args.trace,
        whitespace=args.whitespace,
        nameguard=not args.no_nameguard
    )

