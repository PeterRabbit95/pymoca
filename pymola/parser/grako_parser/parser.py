#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# CAVEAT UTILITOR
# This file was automatically generated by Grako.
#    https://bitbucket.org/apalala/grako/
# Any changes you make to it will be overwritten the
# next time the file is generated.
#

from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import * # noqa
from grako.exceptions import * # noqa


__version__ = '14.163.20.05.13'


class ModelicaParser(Parser):
    def __init__(self, whitespace=None, **kwargs):
        super(ModelicaParser, self).__init__(whitespace=whitespace, **kwargs)

    @rule_def
    def _stored_definition_(self):
        with self._optional():
            self._token('within')
            self._cut()
            with self._optional():
                self._name_()
            self.ast['within'] = self.last_node
            self._token(';')
        def block1():
            with self._optional():
                self._token('final')
            self.ast['final'] = self.last_node
            self._class_definition_()
            self.ast['class_definition'] = self.last_node
            self._token(';')
        self._positive_closure(block1)

    @rule_def
    def _class_definition_(self):
        with self._optional():
            self._token('encapsulated')
        self.ast['encapsulated'] = self.last_node
        self._class_prefixes_()
        self.ast['class_prefixes'] = self.last_node
        self._class_specifier_()
        self.ast['class_specifier'] = self.last_node

    @rule_def
    def _class_prefixes_(self):
        with self._optional():
            self._token('partial')
        self.ast['partial'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    self._token('class')
                with self._option():
                    self._token('model')
                with self._option():
                    with self._optional():
                        self._token('operator')
                    self._token('record')
                with self._option():
                    self._token('block')
                with self._option():
                    with self._optional():
                        self._token('expandable')
                    self._token('connector')
                with self._option():
                    self._token('type')
                with self._option():
                    self._token('package')
                with self._option():
                    with self._optional():
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('pure')
                                with self._option():
                                    self._token('impure')
                                self._error('expecting one of: impure pure')
                    with self._optional():
                        self._token('operator')
                    self._token('function')
                with self._option():
                    self._token('operator')
                self._error('expecting one of: model function pure type class expandable block connector record package impure operator')
        self.ast['type'] = self.last_node

    @rule_def
    def _class_specifier_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._class_specifier_long_()
                    self.ast['class_specifier_long'] = self.last_node
                with self._option():
                    self._class_specifier_short_()
                    self.ast['class_specifier_short'] = self.last_node
                with self._option():
                    self._class_specifier_enum_()
                    self.ast['class_specifier_enum'] = self.last_node
                with self._option():
                    self._class_specifier_der_()
                    self.ast['class_specifier_der'] = self.last_node
                with self._option():
                    self._class_specifier_extends_()
                    self.ast['class_specifier_extends'] = self.last_node
                self._error('no available options')

    @rule_def
    def _class_specifier_long_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._string_comment_()
        self.ast['comment'] = self.last_node
        self._composition_()
        self.ast['composition'] = self.last_node
        self._token('end')
        self._cut()
        self._IDENT_()
        self.ast['name_check'] = self.last_node

    @rule_def
    def _class_specifier_short_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._token('=')
        self._base_prefix_()
        self.ast['base_prefix'] = self.last_node
        self._name_()
        self.ast['base_name'] = self.last_node
        with self._optional():
            self._array_subscripts_()
        self.ast['subscripts'] = self.last_node
        with self._optional():
            self._class_modification_()
        self.ast['modification'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

    @rule_def
    def _class_specifier_enum_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._token('=')
        self._token('enumeration')
        self._token('(')
        with self._group():
            with self._choice():
                with self._option():
                    with self._optional():
                        self._enum_list_()
                with self._option():
                    self._token(':')
                self._error('expecting one of: :')
        self.ast['enumeration'] = self.last_node
        self._token(')')
        self._comment_()
        self.ast['comment'] = self.last_node

    @rule_def
    def _class_specifier_der_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._token('=')
        self._token('der')
        self._token('(')
        self._name_()
        self._token(',')
        self._IDENT_()
        def block1():
            self._token(',')
            self._IDENT_()
        self._closure(block1)
        self._token(')')
        self._comment_()
        self.ast['comment'] = self.last_node

    @rule_def
    def _class_specifier_extends_(self):
        self._token('extends')
        self._IDENT_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._class_modification_()
        self.ast['class_modification'] = self.last_node
        self._string_comment_()
        self.ast['comment'] = self.last_node
        self._composition_()
        self.ast['composition'] = self.last_node
        self._token('end')
        self._cut()
        self._IDENT_()
        self.ast['name_check'] = self.last_node

    @rule_def
    def _base_prefix_(self):
        self._type_prefix_()

    @rule_def
    def _enum_list_(self):
        self._enumeration_literal_()
        def block0():
            self._token(',')
            self._enumeration_literal_()
        self._closure(block0)

    @rule_def
    def _enumeration_literal_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

    @rule_def
    def _composition_(self):
        self._element_list_()
        self.ast['element_list'] = self.last_node
        def block1():
            with self._choice():
                with self._option():
                    self._token('public')
                    self.ast['access'] = self.last_node
                    self._element_list_()
                    self.ast['element_list'] = self.last_node
                with self._option():
                    self._token('protected')
                    self.ast['access'] = self.last_node
                    self._element_list_()
                    self.ast['element_list'] = self.last_node
                with self._option():
                    self._equation_section_()
                    self.ast['equation_section'] = self.last_node
                with self._option():
                    self._algorithm_section_()
                    self.ast['algorithm_section'] = self.last_node
                self._error('no available options')
        self._closure(block1)
        with self._optional():
            self._token('external')
            with self._optional():
                self._language_specification_()
                self.ast['language_specification'] = self.last_node
            with self._optional():
                self._external_function_call_()
                self.ast['function_call'] = self.last_node
            with self._optional():
                self._annotation_()
                self.ast['function_call_anotation'] = self.last_node
            self._token(';')
        with self._optional():
            self._annotation_()
            self.ast['annotation'] = self.last_node
            self._token(';')

    @rule_def
    def _language_specification_(self):
        self._STRING_()
        self.ast['@'] = self.last_node

    @rule_def
    def _external_function_call_(self):
        with self._optional():
            self._component_reference_()
            self._token('=')
        self._IDENT_()
        self._token('(')
        with self._optional():
            self._expression_list_()
        self._token(')')

    @rule_def
    def _element_list_(self):
        def block0():
            self._element_()
            self.ast['@'] = self.last_node
            self._cut()
            self._token(';')
        self._closure(block0)

    @rule_def
    def _element_(self):
        with self._choice():
            with self._option():
                self._import_clause_()
                self.ast['import_clause'] = self.last_node
            with self._option():
                self._extends_clause_()
                self.ast['extends_clause'] = self.last_node
            with self._option():
                with self._optional():
                    self._token('redeclare')
                self.ast['redeclare'] = self.last_node
                with self._optional():
                    self._token('final')
                self.ast['final'] = self.last_node
                with self._optional():
                    self._token('inner')
                self.ast['inner'] = self.last_node
                with self._optional():
                    self._token('outer')
                self.ast['outer'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._class_definition_()
                                        self.ast['class_definition'] = self.last_node
                                    with self._option():
                                        self._component_clause_()
                                        self.ast['component_clause'] = self.last_node
                                    self._error('no available options')
                        with self._option():
                            self._token('replaceable')
                            self.ast['replaceable'] = self.last_node
                            with self._group():
                                with self._choice():
                                    with self._option():
                                        self._class_definition_()
                                        self.ast['class_definition'] = self.last_node
                                    with self._option():
                                        self._component_clause_()
                                        self.ast['component_clause'] = self.last_node
                                    self._error('no available options')
                            with self._optional():
                                self._constraining_clause_()
                                self.ast['constraining_clause'] = self.last_node
                                self._comment_()
                                self.ast['comment'] = self.last_node
                        self._error('no available options')
            self._error('no available options')

    @rule_def
    def _import_clause_(self):
        self._token('import')
        with self._group():
            with self._choice():
                with self._option():
                    self._IDENT_()
                    self.ast['alias'] = self.last_node
                    self._token('=')
                    self._name_()
                    self.ast['name'] = self.last_node
                with self._option():
                    self._name_()
                    self.ast['name'] = self.last_node
                    with self._optional():
                        self._token('.')
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._token('*')
                                with self._option():
                                    self._token('{')
                                    self._import_list_()
                                    self._token('}')
                                self._error('expecting one of: *')
                self._error('no available options')
        self._comment_()

    @rule_def
    def _import_list_(self):
        self._IDENT_()
        with self._optional():
            self._token(',')
            self._import_list_()

    @rule_def
    def _extends_clause_(self):
        self._token('extends')
        self._name_()
        with self._optional():
            self._class_modification_()
        with self._optional():
            self._annotation_()

    @rule_def
    def _constraining_clause_(self):
        self._token('constrainedby')
        self._name_()
        with self._optional():
            self._class_modification_()

    @rule_def
    def _component_clause_(self):
        self._type_prefix_()
        self.ast['type_prefix'] = self.last_node
        self._type_specifier_()
        self.ast['type_specifier'] = self.last_node
        with self._optional():
            self._array_subscripts_()
        self.ast['array_subscripts'] = self.last_node
        self._component_list_()
        self.ast['component_list'] = self.last_node

    @rule_def
    def _type_prefix_(self):
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('flow')
                with self._option():
                    self._token('stream')
                self._error('expecting one of: stream flow')
        self.ast['flow_type'] = self.last_node
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('discrete')
                with self._option():
                    self._token('parameter')
                with self._option():
                    self._token('constant')
                self._error('expecting one of: constant discrete parameter')
        self.ast['value_type'] = self.last_node
        with self._optional():
            with self._choice():
                with self._option():
                    self._token('input')
                with self._option():
                    self._token('output')
                self._error('expecting one of: output input')
        self.ast['io_type'] = self.last_node

    @rule_def
    def _type_specifier_(self):
        self._name_()
        self.ast['@'] = self.last_node

    @rule_def
    def _component_list_(self):
        self._component_declaration_()
        self.ast['@'] = self.last_node
        def block1():
            self._token(',')
            self._component_declaration_()
            self.ast['@'] = self.last_node
        self._closure(block1)

    @rule_def
    def _component_declaration_(self):
        self._declaration_()
        self.ast['@'] = self.last_node
        with self._optional():
            self._condition_attribute_()
        self.ast['condition'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

    @rule_def
    def _condition_attribute_(self):
        self._token('if')
        self._expression_()
        self.ast['@'] = self.last_node

    @rule_def
    def _declaration_(self):
        self._IDENT_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._array_subscripts_()
        self.ast['array_subscripts'] = self.last_node
        with self._optional():
            self._modification_()
        self.ast['modification'] = self.last_node

    @rule_def
    def _modification_(self):
        with self._choice():
            with self._option():
                with self._group():
                    self._class_modification_()
                    self.ast['class_modification'] = self.last_node
                    with self._optional():
                        self._token('=')
                        self._cut()
                        self._expression_()
                        self.ast['expression'] = self.last_node
            with self._option():
                self._token('=')
                self._cut()
                self._expression_()
                self.ast['expression'] = self.last_node
            with self._option():
                self._token(':=')
                self._cut()
                self._expression_()
                self.ast['expression'] = self.last_node
            self._error('no available options')

    @rule_def
    def _class_modification_(self):
        self._token('(')
        self._cut()
        with self._optional():
            self._argument_list_()
        self.ast['argument_list'] = self.last_node
        self._token(')')

    @rule_def
    def _argument_list_(self):
        self._argument_()
        self.ast['@'] = self.last_node
        def block1():
            self._token(',')
            self._argument_()
            self.ast['@'] = self.last_node
        self._closure(block1)

    @rule_def
    def _argument_(self):
        with self._choice():
            with self._option():
                self._element_modification_or_replaceable_()
                self.ast['@'] = self.last_node
            with self._option():
                self._element_redeclaration_()
                self.ast['@'] = self.last_node
            self._error('no available options')

    @rule_def
    def _element_modification_or_replaceable_(self):
        with self._optional():
            self._token('each')
        self.ast['each'] = self.last_node
        with self._optional():
            self._token('final')
        self.ast['final'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    self._element_modification_()
                    self.ast['element_modification'] = self.last_node
                with self._option():
                    self._element_replaceable_()
                    self.ast['element_replaceable'] = self.last_node
                self._error('no available options')

    @rule_def
    def _element_modification_(self):
        self._name_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._modification_()
        self.ast['modification'] = self.last_node
        self._string_comment_()
        self.ast['comment'] = self.last_node

    @rule_def
    def _element_redeclaration_(self):
        self._token('redeclare')
        with self._optional():
            self._token('each')
        self.ast['each'] = self.last_node
        with self._optional():
            self._token('final')
        self.ast['final'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._short_class_definition_()
                                self.ast['short_class_definition'] = self.last_node
                            with self._option():
                                self._component_clause1_()
                                self.ast['component_clause1'] = self.last_node
                            self._error('no available options')
                with self._option():
                    self._element_replaceable_()
                    self.ast['element_replaceable'] = self.last_node
                self._error('no available options')

    @rule_def
    def _element_replaceable_(self):
        self._token('replaceable')
        with self._group():
            with self._choice():
                with self._option():
                    self._short_class_definition_()
                    self.ast['short_class_definition'] = self.last_node
                with self._option():
                    self._component_clause1_()
                    self.ast['component_clause1'] = self.last_node
                self._error('no available options')
        with self._optional():
            self._constraining_clause_()
        self.ast['constraining_clause'] = self.last_node

    @rule_def
    def _component_clause1_(self):
        self._type_prefix_()
        self.ast['type_prefix'] = self.last_node
        self._type_specifier_()
        self.ast['type_specifier'] = self.last_node
        self._component_declaration1_()
        self.ast['component_declaration1'] = self.last_node

    @rule_def
    def _component_declaration1_(self):
        self._declaration_()
        self.ast['declaration'] = self.last_node
        self._comment_()
        self.ast['comment'] = self.last_node

    @rule_def
    def _short_class_definition_(self):
        self._class_prefixes_()
        self.ast['class_prefixes'] = self.last_node
        self._IDENT_()
        self._token('=')
        with self._group():
            with self._choice():
                with self._option():
                    self._base_prefix_()
                    self.ast['base_prefix'] = self.last_node
                    self._name_()
                    self.ast['base_name'] = self.last_node
                    with self._optional():
                        self._array_subscripts_()
                    self.ast['array_subscripts'] = self.last_node
                    with self._optional():
                        self._class_modification_()
                    self.ast['class_modification'] = self.last_node
                    self._comment_()
                    self.ast['comment'] = self.last_node
                with self._option():
                    self._token('enumeration')
                    self._token('(')
                    with self._group():
                        with self._choice():
                            with self._option():
                                with self._optional():
                                    self._enum_list_()
                                    self.ast['enum_list'] = self.last_node
                            with self._option():
                                self._token(':')
                            self._error('expecting one of: :')
                    self._token(')')
                    self._comment_()
                    self.ast['comment'] = self.last_node
                self._error('no available options')

    @rule_def
    def _equation_section_(self):
        with self._optional():
            self._token('initial')
        self.ast['initial'] = self.last_node
        self._token('equation')
        self._cut()
        def block1():
            self._equation_()
            self.ast['equation'] = self.last_node
            self._cut()
            self._token(';')
        self._closure(block1)

    @rule_def
    def _algorithm_section_(self):
        with self._optional():
            self._token('initial')
        self.ast['initial'] = self.last_node
        self._token('algorithm')
        self._cut()
        def block1():
            self._statement_()
            self.ast['statement'] = self.last_node
            self._cut()
            self._token(';')
        self._closure(block1)

    @rule_def
    def _equation_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._simple_expression_()
                    self._token('=')
                    self._cut()
                    self._expression_()
                with self._option():
                    self._if_equation_()
                with self._option():
                    self._for_equation_()
                with self._option():
                    self._connect_clause_()
                with self._option():
                    self._when_equation_()
                with self._option():
                    self._name_()
                    self._function_call_args_()
                self._error('no available options')
        self._comment_()

    @rule_def
    def _statement_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._component_reference_()
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token(':=')
                                self._cut()
                                self._expression_()
                            with self._option():
                                self._function_call_args_()
                            self._error('no available options')
                with self._option():
                    self._token('(')
                    self._output_expression_list_()
                    self._token(')')
                    self._token(':=')
                    self._cut()
                    self._component_reference_()
                    self._function_call_args_()
                with self._option():
                    self._token('break')
                with self._option():
                    self._token('return')
                with self._option():
                    self._if_statement_()
                with self._option():
                    self._for_statement_()
                with self._option():
                    self._while_statement_()
                with self._option():
                    self._when_statement_()
                self._error('expecting one of: break return')
        self._comment_()

    @rule_def
    def _if_equation_(self):
        self._token('if')
        self._expression_()
        self._token('then')
        def block0():
            self._equation_()
            self._token(';')
        self._closure(block0)
        def block1():
            self._token('elseif')
            self._expression_()
            self._token('then')
            def block2():
                self._equation_()
                self._token(';')
            self._closure(block2)
        self._closure(block1)
        with self._optional():
            self._token('else')
            def block3():
                self._equation_()
                self._token(';')
            self._closure(block3)
        self._token('end')
        self._token('if')

    @rule_def
    def _if_statement_(self):
        self._token('if')
        self._expression_()
        self._token('then')
        def block0():
            self._statement_()
            self._token(';')
        self._closure(block0)
        def block1():
            self._token('elseif')
            self._expression_()
            self._token('then')
            def block2():
                self._statement_()
                self._token(';')
            self._closure(block2)
        self._closure(block1)
        with self._optional():
            self._token('else')
            def block3():
                self._statement_()
                self._token(';')
            self._closure(block3)
        self._token('end')
        self._token('if')

    @rule_def
    def _for_equation_(self):
        self._token('for')
        self._for_indices_()
        self._token('loop')
        def block0():
            self._equation_()
            self._token(';')
        self._closure(block0)
        self._token('end')
        self._token('for')

    @rule_def
    def _for_statement_(self):
        self._token('for')
        self._for_indices_()
        self._token('loop')
        def block0():
            self._statement_()
            self._token(';')
        self._closure(block0)
        self._token('end')
        self._token('for')

    @rule_def
    def _for_indices_(self):
        self._for_index_()
        def block0():
            self._token(',')
            self._for_index_()
        self._closure(block0)

    @rule_def
    def _for_index_(self):
        self._IDENT_()
        with self._optional():
            self._token('in')
            self._expression_()

    @rule_def
    def _while_statement_(self):
        self._token('while')
        self._expression_()
        self._token('loop')
        def block0():
            self._statement_()
            self._token(';')
        self._closure(block0)
        self._token('end')
        self._token('while')

    @rule_def
    def _when_equation_(self):
        self._token('when')
        self._expression_()
        self._token('then')
        def block0():
            self._equation_()
            self._token(';')
        self._closure(block0)
        def block1():
            self._token('elsewhen')
            self._expression_()
            self._token('then')
            def block2():
                self._equation_()
                self._token(';')
            self._closure(block2)
        self._closure(block1)
        self._token('end')
        self._token('when')

    @rule_def
    def _when_statement_(self):
        self._token('when')
        self._expression_()
        self._token('then')
        def block0():
            self._statement_()
            self._token(';')
        self._closure(block0)
        def block1():
            self._token('elsewhen')
            self._expression_()
            self._token('then')
            def block2():
                self._statement_()
                self._token(';')
            self._closure(block2)
        self._closure(block1)
        self._token('end')
        self._token('when')

    @rule_def
    def _connect_clause_(self):
        self._token('connect')
        self._token('(')
        self._component_reference_()
        self._token(',')
        self._component_reference_()
        self._token(')')

    @rule_def
    def _expression_(self):
        with self._choice():
            with self._option():
                self._simple_expression_()
            with self._option():
                with self._group():
                    self._token('if')
                    self._expression_()
                    self._token('then')
                    self._expression_()
                    def block0():
                        self._token('elseif')
                        self._expression_()
                        self._token('then')
                        self._expression_()
                    self._closure(block0)
                    self._token('else')
                    self._expression_()
            self._error('no available options')

    @rule_def
    def _simple_expression_(self):
        with self._group():
            self._logical_expression_()
            with self._optional():
                self._token(':')
                self._logical_expression_()
                with self._optional():
                    self._token(':')
                    self._logical_expression_()
        self.ast['simple_expression'] = self.last_node

    @rule_def
    def _logical_expression_(self):
        with self._group():
            self._logical_term_()
            def block1():
                self._token('or')
                self._logical_term_()
            self._closure(block1)
        self.ast['logical_expression'] = self.last_node

    @rule_def
    def _logical_term_(self):
        with self._group():
            self._logical_factor_()
            def block1():
                self._token('and')
                self._logical_factor_()
            self._closure(block1)
        self.ast['logical_term'] = self.last_node

    @rule_def
    def _logical_factor_(self):
        with self._optional():
            self._token('not')
        self.ast['not_'] = self.last_node
        self._relation_()
        self.ast['relation'] = self.last_node

    @rule_def
    def _relation_(self):
        with self._group():
            self._arithmetic_expression_()
            with self._optional():
                self._rel_op_()
                self._arithmetic_expression_()
        self.ast['arithmetic_expression'] = self.last_node

    @rule_def
    def _rel_op_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('<')
                with self._option():
                    self._token('<=')
                with self._option():
                    self._token('>')
                with self._option():
                    self._token('>=')
                with self._option():
                    self._token('==')
                with self._option():
                    self._token('<>')
                self._error('expecting one of: > >= <> <= < ==')
        self.ast['@'] = self.last_node

    @rule_def
    def _arithmetic_expression_(self):
        with self._optional():
            self._add_op_()
        self._term_()
        def block0():
            self._add_op_()
            self._term_()
        self._closure(block0)

    @rule_def
    def _add_op_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('+')
                with self._option():
                    self._token('-')
                with self._option():
                    self._token('.+')
                with self._option():
                    self._token('.-')
                self._error('expecting one of: + .- .+ -')
        self.ast['@'] = self.last_node

    @rule_def
    def _term_(self):
        self._factor_()
        def block0():
            self._mul_op_()
            self._factor_()
        self._closure(block0)

    @rule_def
    def _mul_op_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('*')
                with self._option():
                    self._token('/')
                with self._option():
                    self._token('.*')
                with self._option():
                    self._token('./')
                self._error('expecting one of: ./ .* * /')
        self.ast['@'] = self.last_node

    @rule_def
    def _factor_(self):
        self._primary_()
        with self._optional():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('^')
                    with self._option():
                        self._token('.^')
                    self._error('expecting one of: ^ .^')
            self._primary_()

    @rule_def
    def _primary_(self):
        with self._choice():
            with self._option():
                self._UNSIGNED_NUMBER_()
            with self._option():
                self._STRING_()
            with self._option():
                self._token('false')
            with self._option():
                self._token('true')
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._name_()
                        with self._option():
                            self._token('der')
                        with self._option():
                            self._token('initial')
                        self._error('expecting one of: der initial')
                self._function_call_args_()
            with self._option():
                self._component_reference_()
            with self._option():
                self._token('(')
                self._output_expression_list_()
                self._token(')')
            with self._option():
                self._token('[')
                self._expression_list_()
                def block1():
                    self._token(';')
                    self._expression_list_()
                self._closure(block1)
                self._token(']')
            with self._option():
                self._token('{')
                self._function_arguments_()
                self._token('}')
            with self._option():
                self._token('end')
            self._error('expecting one of: true end false')

    @rule_def
    def _name_(self):
        with self._optional():
            self._token('.')
        self._IDENT_()
        self.ast['@'] = self.last_node
        def block1():
            self._token('.')
            self._IDENT_()
            self.ast['@'] = self.last_node
        self._closure(block1)

    @rule_def
    def _component_reference_(self):
        with self._optional():
            self._token('.')
        self._IDENT_()
        with self._optional():
            self._array_subscripts_()
        def block0():
            self._token('.')
            self._IDENT_()
            with self._optional():
                self._array_subscripts_()
        self._closure(block0)

    @rule_def
    def _function_call_args_(self):
        self._token('(')
        with self._optional():
            self._function_arguments_()
        self._token(')')

    @rule_def
    def _function_arguments_(self):
        with self._choice():
            with self._option():
                self._function_argument_()
                with self._optional():
                    with self._choice():
                        with self._option():
                            self._token(',')
                            self._function_arguments_()
                        with self._option():
                            self._token('for')
                            self._for_indices_()
                        self._error('no available options')
            with self._option():
                self._named_arguments_()
            self._error('no available options')

    @rule_def
    def _named_arguments_(self):
        self._named_argument_()
        with self._optional():
            self._token(',')
            self._named_arguments_()

    @rule_def
    def _named_argument_(self):
        self._IDENT_()
        self._token('=')
        self._function_argument_()

    @rule_def
    def _function_argument_(self):
        with self._choice():
            with self._option():
                self._token('function')
                self._name_()
                self._token('(')
                with self._optional():
                    self._named_arguments_()
                self._token(')')
            with self._option():
                self._expression_()
            self._error('no available options')

    @rule_def
    def _output_expression_list_(self):
        with self._optional():
            self._expression_()
        def block0():
            self._token(',')
            with self._optional():
                self._expression_()
        self._closure(block0)

    @rule_def
    def _expression_list_(self):
        self._expression_()
        def block0():
            self._token(',')
            self._expression_()
        self._closure(block0)

    @rule_def
    def _array_subscripts_(self):
        self._token('[')
        self._subscript_()
        def block0():
            self._token(',')
            self._subscript_()
        self._closure(block0)
        self._token(']')

    @rule_def
    def _subscript_(self):
        with self._choice():
            with self._option():
                self._token(':')
            with self._option():
                self._expression_()
            self._error('expecting one of: :')

    @rule_def
    def _comment_(self):
        self._string_comment_()
        self.ast['comment'] = self.last_node
        with self._optional():
            self._annotation_()
        self.ast['annotation'] = self.last_node

    @rule_def
    def _string_comment_(self):
        with self._optional():
            self._STRING_()
            def block1():
                self._token('+')
                self._STRING_()
            self._closure(block1)
        self.ast['@'] = self.last_node

    @rule_def
    def _annotation_(self):
        self._token('annotation')
        self._class_modification_()
        self.ast['@'] = self.last_node

    @rule_def
    def _re_IDENT_(self):
        self._pattern(r'[_a-zA-Z][_a-zA-Z0-9]*')

    @rule_def
    def _re_STRING_(self):
        self._pattern(r'"[^"]+"')

    @rule_def
    def _re_UNSIGNED_NUMBER_(self):
        self._pattern(r'[0-9]+([\.][0-9]+)?([eE][\+\-]?[0-9]+)?')

    @rule_def
    def _IDENT_(self):
        self._re_IDENT_()

    @rule_def
    def _STRING_(self):
        self._re_STRING_()

    @rule_def
    def _UNSIGNED_NUMBER_(self):
        self._re_UNSIGNED_NUMBER_()


class ModelicaSemanticParser(CheckSemanticsMixin, ModelicaParser):
    pass


class ModelicaSemantics(object):
    def stored_definition(self, ast):
        return ast

    def class_definition(self, ast):
        return ast

    def class_prefixes(self, ast):
        return ast

    def class_specifier(self, ast):
        return ast

    def class_specifier_long(self, ast):
        return ast

    def class_specifier_short(self, ast):
        return ast

    def class_specifier_enum(self, ast):
        return ast

    def class_specifier_der(self, ast):
        return ast

    def class_specifier_extends(self, ast):
        return ast

    def base_prefix(self, ast):
        return ast

    def enum_list(self, ast):
        return ast

    def enumeration_literal(self, ast):
        return ast

    def composition(self, ast):
        return ast

    def language_specification(self, ast):
        return ast

    def external_function_call(self, ast):
        return ast

    def element_list(self, ast):
        return ast

    def element(self, ast):
        return ast

    def import_clause(self, ast):
        return ast

    def import_list(self, ast):
        return ast

    def extends_clause(self, ast):
        return ast

    def constraining_clause(self, ast):
        return ast

    def component_clause(self, ast):
        return ast

    def type_prefix(self, ast):
        return ast

    def type_specifier(self, ast):
        return ast

    def component_list(self, ast):
        return ast

    def component_declaration(self, ast):
        return ast

    def condition_attribute(self, ast):
        return ast

    def declaration(self, ast):
        return ast

    def modification(self, ast):
        return ast

    def class_modification(self, ast):
        return ast

    def argument_list(self, ast):
        return ast

    def argument(self, ast):
        return ast

    def element_modification_or_replaceable(self, ast):
        return ast

    def element_modification(self, ast):
        return ast

    def element_redeclaration(self, ast):
        return ast

    def element_replaceable(self, ast):
        return ast

    def component_clause1(self, ast):
        return ast

    def component_declaration1(self, ast):
        return ast

    def short_class_definition(self, ast):
        return ast

    def equation_section(self, ast):
        return ast

    def algorithm_section(self, ast):
        return ast

    def equation(self, ast):
        return ast

    def statement(self, ast):
        return ast

    def if_equation(self, ast):
        return ast

    def if_statement(self, ast):
        return ast

    def for_equation(self, ast):
        return ast

    def for_statement(self, ast):
        return ast

    def for_indices(self, ast):
        return ast

    def for_index(self, ast):
        return ast

    def while_statement(self, ast):
        return ast

    def when_equation(self, ast):
        return ast

    def when_statement(self, ast):
        return ast

    def connect_clause(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def simple_expression(self, ast):
        return ast

    def logical_expression(self, ast):
        return ast

    def logical_term(self, ast):
        return ast

    def logical_factor(self, ast):
        return ast

    def relation(self, ast):
        return ast

    def rel_op(self, ast):
        return ast

    def arithmetic_expression(self, ast):
        return ast

    def add_op(self, ast):
        return ast

    def term(self, ast):
        return ast

    def mul_op(self, ast):
        return ast

    def factor(self, ast):
        return ast

    def primary(self, ast):
        return ast

    def name(self, ast):
        return ast

    def component_reference(self, ast):
        return ast

    def function_call_args(self, ast):
        return ast

    def function_arguments(self, ast):
        return ast

    def named_arguments(self, ast):
        return ast

    def named_argument(self, ast):
        return ast

    def function_argument(self, ast):
        return ast

    def output_expression_list(self, ast):
        return ast

    def expression_list(self, ast):
        return ast

    def array_subscripts(self, ast):
        return ast

    def subscript(self, ast):
        return ast

    def comment(self, ast):
        return ast

    def string_comment(self, ast):
        return ast

    def annotation(self, ast):
        return ast

    def re_IDENT(self, ast):
        return ast

    def re_STRING(self, ast):
        return ast

    def re_UNSIGNED_NUMBER(self, ast):
        return ast

    def IDENT(self, ast):
        return ast

    def STRING(self, ast):
        return ast

    def UNSIGNED_NUMBER(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = ModelicaParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in ModelicaParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for Modelica.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(args.file, args.startrule, trace=args.trace, whitespace=args.whitespace)
